<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java数据结构与算法, BlogLee">
    <meta name="description" content="数据结构与算法（java）时间复杂度：程序执行完所需的时间
空间复杂度：程序程序所需要的内存
Comparable接口介绍由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序规则的">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java数据结构与算法 | BlogLee</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="BlogLee" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">BlogLee</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Concat</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">BlogLee</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Concat
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java数据结构与算法</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">Java数据结构与算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-03
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    28.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    118 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数据结构与算法（java）"><a href="#数据结构与算法（java）" class="headerlink" title="数据结构与算法（java）"></a>数据结构与算法（java）</h1><p><strong>时间复杂度：程序执行完所需的时间</strong></p>
<p><strong>空间复杂度：程序程序所需要的内存</strong></p>
<h2 id="Comparable接口介绍"><a href="#Comparable接口介绍" class="headerlink" title="Comparable接口介绍"></a><strong>Comparable接口介绍</strong></h2><p>由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序规则的，在这里我们以案例的形式对Comparable接口做一个简单的回顾。</p>
<p><strong>需求：</strong></p>
<p> 1.定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；</p>
<p> 2.定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试</p>
<p>student类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student implements Comparable&lt;Student&gt;{
    private String username;
    private int age;

    public Student() {
    }

    public Student(String username, int age) {
        this.username = username;
        this.age = age;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "username='" + username + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(Student o) {
        //比较年龄
        return this.getAge() - o.getAge();
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestComparable {
    public static void main(String[] args) {

        Student student1 = new Student("张三",18);
        Student student2 = new Student("李四",20);

        Comparable max = getMax(student1, student2);
        System.out.println(max);

    }

    public static Comparable getMax(Comparable c1,Comparable c2){
        int result = c1.compareTo(c2);
        //如果result &lt; 0,则c1b比c2小 :如果result &gt; 0 :则c1比c2大; 如果result == 0,则c工和c2一样大﹔
        if (result &gt;= 0){
            return c1;
        }else {
            return c2;
        }

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><table>
<thead>
<tr>
<th>简单的排序</th>
<th>高级的排序</th>
</tr>
</thead>
<tbody><tr>
<td><strong>冒泡排序</strong></td>
<td><strong>希尔排序</strong></td>
</tr>
<tr>
<td><strong>选择排序</strong></td>
<td><strong>归并排序</strong></td>
</tr>
<tr>
<td><strong>插入排序</strong></td>
<td><strong>快速排序</strong></td>
</tr>
</tbody></table>
<h3 id="简单的排序"><a href="#简单的排序" class="headerlink" title="简单的排序"></a>简单的排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p>
<p><strong>需求：</strong></p>
<p>排序前：{4,5,6,3,2,1}</p>
<p>排序后：{1,2,3,4,5,6}</p>
<h5 id="排序原理："><a href="#排序原理：" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><ol>
<li><p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220925224914653.png" alt="image-20220925224914653"></p>
<h5 id="冒泡排序API设计："><a href="#冒泡排序API设计：" class="headerlink" title="冒泡排序API设计："></a><strong>冒泡排序API设计：</strong></h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Bubble</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Bubble()：创建Bubble对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public static void sort(Comparable[] a)：对数组内的元素进行排序 ；                                                                                                                                        2、private static boolean greater(Comparable v,Comparable w)：判断v是否大于w；                                                                                                                   3、private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Bubble {

    //对数组a中的元素进行排序、
    public static void sort(Comparable[] a){
        for (int i = a.length - 1; i &gt; 0; i--) {
            for (int j = 0; j &lt; i ; j++) {
                //比较索引j和索引j+1的值
                if (greater(a[j],a[j+1])){
                    exch(a,j,j+1);
                }
            }
        }
    }

    //比较v元素是否大于w元素
    private static boolean greater(Comparable v,Comparable w){

        return v.compareTo(w) &gt; 0;
    }

    //数组元素i和j交换位置
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BubbleTest {
    public static void main(String[] args) {
        Integer[] arr = {4,5,6,3,2,1};
        Bubble.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220925225201495.png" alt="image-20220925225201495"></p>
<h5 id="冒泡排序的时间复杂度分析"><a href="#冒泡排序的时间复杂度分析" class="headerlink" title="冒泡排序的时间复杂度分析"></a><strong>冒泡排序的时间复杂度分析</strong></h5><p>冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p>
<p>在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么，</p>
<p>元素比较的次数为：</p>
<p> (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>元素交换的次数为：</p>
<p> (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>总执行次数为：</p>
<p> (N^2 /2 - N/2) + (N^2 /2 - N/2)=N^2-N;</p>
<p><strong>最终冒泡排序的时间复杂度为O(N^2).</strong></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h4><p>选择排序是一种更加简单直观的排序方法。</p>
<p><strong>需求：</strong></p>
<p>排序前：{4,6,8,7,9,2,10,1}</p>
<p>排序后：{1,2,4,5,7,8,9,10}</p>
<h5 id="排序原理：-1"><a href="#排序原理：-1" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><p> 1、每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引</p>
<p> 2、交换第一个索引处和最小值所在的索引处的值</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220925231303800.png" alt="image-20220925231303800"></p>
<h5 id="选择排序API设计："><a href="#选择排序API设计：" class="headerlink" title="选择排序API设计："></a>选择排序API设计：</h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Selection</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Selection()：创建Selection对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public static void sort(Comparable[] a)：对数组内的元素进行排序 ；                                                                                                                                    2、private static boolean greater(Comparable v,Comparable w):判断v是否大于w；                                                                                                                 3、private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>Selection类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Selection {
    //对数组a中的元素进行排序、
    public static void sort(Comparable[] a){
        for (int i = 0; i &lt;= a.length - 2; i++) {
            //定义一个变量,记录最小元素所在的索引﹔默认为参与选择排序的第一个元素所在的位置
            int minIndex = i;
            for (int j = i+1; j &lt; a.length; j++) {
                //需要比较最小索引minIndex处的值与索引j处的值;
                if (greater(a[minIndex],a[j])){
                    minIndex = j;
                }
            }

            //交换最小元素所在索引minIndex处的值和索引i处的值
            exch(a,i,minIndex);


        }
    }

    //比较v元素是否大于w元素
    private static boolean greater(Comparable v,Comparable w){

        return v.compareTo(w) &gt; 0;
    }

    //数组元素i和j交换位置
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SelectionTest {
    public static void main(String[] args) {
        Integer[] arr = {4,6,8,7,9,2,10,1};
        Selection.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220925232348346.png" alt="image-20220925232348346"></p>
<h5 id="选择排序的时间复杂度分析："><a href="#选择排序的时间复杂度分析：" class="headerlink" title="选择排序的时间复杂度分析："></a><strong>选择排序的时间复杂度分析：</strong></h5><p>选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据交换次数和数据比较次数：</p>
<p>数据比较次数：</p>
<p> (N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>数据交换次数：N-1</p>
<p>时间复杂度：N^2 / 2-N/2+（N-1）=N^2/2+N/2-1;</p>
<p><strong>故时间复杂度为O(N^2);</strong></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序（Insertion sort）是一种简单直观且稳定的排序算法。</p>
<p>插入排序的工作方式非常像人们排序一手扑克牌一样。开始时，我们的左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220925232807530.png" alt="image-20220925232807530"></p>
<p><strong>需求：</strong></p>
<p>排序前：{4,3,2,10,12,1,5,6}</p>
<p>排序后：{1,2,3,4,5,6,10,12}</p>
<h5 id="排序原理：-2"><a href="#排序原理：-2" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><p>1.把所有的元素分为两组，已经排序的和未排序的；</p>
<p>2.找到未排序的组中的第一个元素，向已经排序的组中进行插入；</p>
<p>3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220925233545547.png" alt="image-20220925233545547"></p>
<h5 id="插入排序API设计："><a href="#插入排序API设计：" class="headerlink" title="插入排序API设计："></a>插入排序API设计：</h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Insertion</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Insertion()：创建Insertion对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public static void sort(Comparable[] a)：对数组内的元素进行排序                                                                                                                                        2、private static boolean greater(Comparable v,Comparable w):判断v是否大于w                                                                                                                       3、private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>Insertion</strong>类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Insertion {
    //对数组a中的元素进行排序、
    public static void sort(Comparable[] a){
        for (int i = 1; i &lt; a.length; i++) {
            for (int j = i; j &gt; 0; j--) {
                //比较索引lj处的值和索引j-1处的值,如果索引j-1处的值比索引j处的值大,则交换数据;如果不大,那么就找到合适的位置了退出循环即可;

                if (greater(a[j-1],a[j])){
                   exch(a,j-1,j);
               }else {
                   break;
               }
            }

        }
    }

    //比较v元素是否大于w元素
    private static boolean greater(Comparable v,Comparable w){

        return v.compareTo(w) &gt; 0;
    }

    //数组元素i和j交换位置
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class InsertionTest {
    public static void main(String[] args) {
        Integer[] arr = {4,3,2,10,12,1,5,6};
        Insertion.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220925234453773.png" alt="image-20220925234453773"></p>
<h5 id="插入排序的时间复杂度分析"><a href="#插入排序的时间复杂度分析" class="headerlink" title="插入排序的时间复杂度分析"></a><strong>插入排序的时间复杂度分析</strong></h5><p>插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p>
<p>最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么：</p>
<p>比较的次数为：</p>
<p>(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>交换的次数为：</p>
<p>(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>
<p>总执行次数为：</p>
<p>(N^2 / 2-N/2)+(N^2 / 2-N/2)=N^2-N;</p>
<p><strong>最终插入排序的时间复杂度为O(N^2).</strong></p>
<h3 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h4><p>希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。</p>
<p>前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为{2,5,7,9,10}，未排序的分组元素为{1,8}，那么下一个待插入元素为1，我们需要拿着1从后往前，依次和10,9,7,5,2进行交换位置，才能完成真正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数，这样的需求如何实现呢？接下来我们来看看希尔排序的原理。</p>
<p><strong>需求：</strong></p>
<p>排序前：{9,1,2,5,7,4,8,6,3,5}</p>
<p>排序后：{1,2,3,4,5,5,6,7,8,9}</p>
<h5 id="排序原理：-3"><a href="#排序原理：-3" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><p> 1、选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；</p>
<p> 2、对分好组的每一组数据完成插入排序；</p>
<p> 3、减小增长量，最小减为1，重复第二步操作。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220926152257632.png" alt="image-20220926152257632"></p>
<p><strong>增长量h的确定：增长量h的值每一固定的规则，我们这里采用以下规则：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int h=1 ;
int[] arr = {9,1,2,5,7,4,8,6,3,5};
lenght = arr.length / 2;
while(h &lt; lenght){ 
    h=2h+1；//3,7 
}//循环结束后我们就可以确定h的最大值； 

//h的减小规则为： 
h=h/2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="希尔排序的API设计："><a href="#希尔排序的API设计：" class="headerlink" title="希尔排序的API设计："></a>希尔排序的API设计：</h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Shell</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Shell()：创建Shell对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public static void sort(Comparable[] a)：对数组内的元素进行排序                                                                                                                                       2、private static boolean greater(Comparable v,Comparable w):判断v是否大于w                                                                                                                                                 3、private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="希尔排序的代码实现："><a href="#希尔排序的代码实现：" class="headerlink" title="希尔排序的代码实现："></a><strong>希尔排序的代码实现：</strong></h5><p>Shell类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Shell {
    //对数组a中的元素进行排序、
    public static void sort(Comparable[] a){
        //根据数组a的长度来确定增长量h的初始值
        int h = 1;
        while (h &lt; a.length/2){
            h = 2*h + 1;
        }
        //希尔排序
        //1、找到待插入的元素
        for (int i = h; i &lt; a.length; i++) {
            //2、将待插入的元素插到有序序列中
            for (int j = i; j &gt;= h ; j-= h) {
                //将待插入的元素a[j]与a[j-h]比较，如果a[j-h] &gt; a[j]
                if (greater(a[j-h],a[j])){
                    //交换元素
                    exch(a,j-h,j);
                }else {
                    //待插入元素已经找到合适的位置了，结束循环
                    break;
                }
            }

        }
    }

    //比较v元素是否大于w元素
    private static boolean greater(Comparable v,Comparable w){

        return v.compareTo(w) &gt; 0;
    }

    //数组元素i和j交换位置
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ShellTest {
    public static void main(String[] args) {
        Integer[] arr = {9,1,2,5,7,4,8,6,3,5};
        Insertion.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="希尔排序的时间复杂度分析"><a href="#希尔排序的时间复杂度分析" class="headerlink" title="希尔排序的时间复杂度分析"></a><strong>希尔排序的时间复杂度分析</strong></h5><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h4><p><strong>定义：</strong></p>
<p>定义方法时，在方法内部调用方法本身，称之为递归.</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void show(){ 
    System.out.println("aaaa"); 
    show(); 
} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>作用：</strong></p>
<p>它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</p>
<p><strong>注意事项：</strong></p>
<p>在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220926155613251.png" alt="image-20220926155613251"></p>
<p><strong>需求：</strong></p>
<p>请定义一个方法，使用递归完成求N的阶乘；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">分析： 
1!: 1 
2!: 2*1=2*1! 
3!: 3*2*1=3*2! 
4!: 4*3*2*1=4*3! ... 
n!: n*(n-1)*(n-2)...*2*1=n*(n-1)! 
所以，假设有一个方法factorial(n)用来求n的阶乘，那么n的阶乘还可以表示为n*factorial(n-1) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>代码实现：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestFactorial {
    public static void main(String[] args) {

        //求n的阶乘
        long factorial = factorial(10000);
        System.out.println(factorial);

    }

    //求n的阶乘
    public static long factorial(int n){
        if (n == 1){
            return 1;
        }
         return n*factorial(n-1);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p><strong>需求：</strong></p>
<p>排序前：{8,4,5,7,1,3,6,2}</p>
<p>排序后：{1,2,3,4,5,6,7,8}</p>
<h5 id="排序原理：-4"><a href="#排序原理：-4" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><p> 1、尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</p>
<p> 2、将相邻的两个子组进行合并成一个有序的大组；</p>
<p> 3、不断的重复步骤2，直到最终只有一个组为止。</p>
<h5 id="归并排序API设计"><a href="#归并排序API设计" class="headerlink" title="归并排序API设计"></a>归并排序API设计</h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Merge</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Merge()：创建Merge对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public static void sort(Comparable[] a)：对数组内的元素进行排序                                                                                                                                  2、private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进                                                                                   3、private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到所以mid为一个子                                                                                                4、private static boolean less(Comparable v,Comparable w):判断v是否小于w                                                                                                                                 5、private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private static Comparable[] assist：完成归并操作需要的辅助数组</td>
</tr>
</tbody></table>
<h5 id="归并原理："><a href="#归并原理：" class="headerlink" title="归并原理："></a><strong>归并原理：</strong></h5><p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220927125922511.png" alt="image-20220927125922511"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220927130400266.png" alt="image-20220927130400266"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220927130556729.png" alt="image-20220927130556729"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220927130705514.png" alt="image-20220927130705514"></p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><p>Merge类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Merge {
    private static Comparable[] assist; //完成归并操作需要的辅助数组



    //判断元素v是否比元素w小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) &lt; 0;
    }

    //对数组进行排序
    public static void sort(Comparable[] a){
        //1。列始化辅组数组assist ;
        assist = new Comparable[a.length];

        //2.定义一个low变量﹔和height变量﹐分别记录数组中最小的索引和最大的索引﹔
        int low = 0;
        int height = a.length - 1;

        //3.调用sort重载方法完成数组α中,从索引low到索引height的元素的排序
        sort(a,low,height);

    }

    //对数组中从low到height的元素进行排序
    public static void sort(Comparable[] a,int low, int height){
       //安全性校验
        if (height &lt;= low){
            return;
        }

        //对low到height的数据进行分组（分为两组）
        int mid = low + (height-low)/2;

        //分别对每一组数据进行排序
        sort(a,low,mid);
        sort(a,mid+1,height);

        //再把两组中的数据进行归并
        merge(a,low,mid,height);
    }

    //对数组中，从low到mid为一组，从mid到height为一组，对两组数据进行归并
    private static void merge(Comparable[] a, int low, int mid, int height) {
        //定义三个指针
        int i = low; //指向assist数组中开始填充数据的索引
        int p1 = low; //指向第一组数据的第一个元素
        int p2 = mid+1; //指向第二组数据的第一个元素


        //遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处
        while (p1 &lt;= mid &amp;&amp; p2 &lt;= height){
            //比较对应索引处的值
            if (less(a[p1],a[p2])){
                assist[i++] = a[p1++];
            }else {
                assist[i++] = a[p2++];
            }
        }

        //遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处
        while (p1 &lt;= mid){
            assist[i++] = a[p1++];
        }

        //遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处
        while (p2 &lt;= height){
            assist[i++] = a[p2++];
        }

        //把辅助数组中的元素拷贝到原数组中
        for (int index = low; index &lt;= height; index++) {
            a[index] = assist[index];
        }
    }


    //数组元素i和j交换位置
    private static void exch(Comparable[] a, int i, int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeTest {
    public static void main(String[] args) {
        Integer[] arr = {8,4,5,7,1,3,6,2};
        Merge.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="归并排序时间复杂度分析："><a href="#归并排序时间复杂度分析：" class="headerlink" title="归并排序时间复杂度分析："></a><strong>归并排序时间复杂度分析：</strong></h5><p>归并排序是分治思想的最典型的例子，上面的算法中，对a[lo…hi]进行排序，先将它分为a[lo…mid]和a[mid+1…hi]两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220927125148867.png" alt="image-20220927125148867"></p>
<p>用树状图来描述归并，如果一个数组有8个元素，那么它将每次除以2找最小的子数组，共拆log8次，值为3，所以树共有3层,那么自顶向下第k层有2^k个子数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较。因此每层的比较次数为 2^k * 2^(3-k)=2^3,那么3层总共为 3*2^3。</p>
<p>假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面3<em>2^3中 的3这个层数，最终得出的归并排序的时间复杂度为：log2(n)</em> 2^(log2(n))=log2(n)<em>n,根据大O推导法则，忽略底数，*<em>最终归并排序的时间复杂度为O(nlogn);</em></em></p>
<p><strong>归并排序的缺点：</strong></p>
<p>需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p><strong>需求：</strong></p>
<p>排序前:{6, 1, 2, 7, 9, 3, 4, 5, 8}</p>
<p>排序后:{1, 2, 3, 4, 5, 6, 7, 8, 9}</p>
<h5 id="排序原理：-5"><a href="#排序原理：-5" class="headerlink" title="排序原理："></a><strong>排序原理：</strong></h5><p>1、首先设定一个分界值，通过该分界值将数组分成左右两部分；</p>
<p>2、将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值；</p>
<p>3、然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
<p>4、重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</p>
<h5 id="快速排序API设计"><a href="#快速排序API设计" class="headerlink" title="快速排序API设计"></a>快速排序API设计</h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong><strong>Quick</strong></strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Quick()：创建Quick对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public static void sort(Comparable[] a)：对数组内的元素进行排序                                                                                                                                    2、private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素                                                                                            3、public static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引 lo到索引 hi之间的元                                                                                                                                       4、private static boolean less(Comparable v,Comparable w):判断v是否小于w                                                                                                                        5、private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<h5 id="切分原理："><a href="#切分原理：" class="headerlink" title="切分原理："></a><strong>切分原理：</strong></h5><p>把一个数组切分成两个子数组的基本思想：</p>
<p>1、找一个基准值，用两个指针分别指向数组的头部和尾部；</p>
<p>2、先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；</p>
<p>3、再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；</p>
<p>4、交换当前左边指针位置和右边指针位置的元素；</p>
<p>5、重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220928230703110.png" alt="image-20220928230703110"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220928230817050.png" alt="image-20220928230817050"></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><p>Quick类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Quick {

    //对数组内的元素进行排序
    public static void sort(Comparable[] a){
        int lo = 0;
        int hi = a.length - 1;
        sort(a,lo,hi);
    }

    //对数组a中从索引lo到索引hi之间的元素
    private static void sort(Comparable[] a, int lo, int hi){
        //安全性校验
        if(hi &lt;= lo){
            return;
        }

        //需要对数组中lo索引到hi索引处的元素进行分组（左子组和右子组）
        int partition = partition(a, lo, hi);//返回的是分组的分界值所在的索引，分界值位置变换后的索引

        //让左子组有序
        sort(a,lo,partition-1);

        //让右子组有序
        sort(a,partition+1,hi);

    }

    //对数组a中，从索引 lo到索引 hi之间的元
    public static int partition(Comparable[] a,int lo,int hi){
        //确定分界值
        Comparable key = a[lo];

        //定义两个指针，分别指向待切分元素的最小元素索引处的最大索引处的下一个位置
        int left = lo; //定义一个左侧指针，初始指向最左边的元素
        int right = hi + 1;  //定义一个右侧指针，初始指向左右侧的元素下一个位置

        //切分
        while (true){
            //先从右往左扫描，移动指针right，找到一个比分界值小的元素，停止
            while (less(key,a[--right])){
                if (right == lo){
                    break;
                }
            }


            //先从左往右扫描，移动指针left，找到一个比分界值大的元素，停止

            while (less(a[++left],key)){
                if (left == hi){
                    break;
                }
            }
            //判断left &gt;= right，如果是，则证明扫描完毕。结束循环，如果不是，则交换元素
            if (left &gt;= right){
                break;
            }else {
                exch(a,left,right);
            }

        }

        //交换分界值
        exch(a,lo,right);

        return right;
    }

    //判断v是否小于w
    private static boolean less(Comparable v,Comparable w){
        return v.compareTo(w) &lt; 0;
    }

    //交换a数组中，索引i和索引j处的值
    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class QuickTest {
    public static void main(String[] args) {
        Integer[] arr = {6, 1, 2, 7, 9, 3, 4, 5, 8};
        Quick.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="快速排序和归并排序的区别："><a href="#快速排序和归并排序的区别：" class="headerlink" title="快速排序和归并排序的区别："></a><strong>快速排序和归并排序的区别：</strong></h5><p>快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。</p>
<h5 id="快速排序时间复杂度分析："><a href="#快速排序时间复杂度分析：" class="headerlink" title="快速排序时间复杂度分析："></a><strong>快速排序时间复杂度分析：</strong></h5><p>快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个快速排序的时间复杂度和切分的次数相关。</p>
<p><strong>最优情况：</strong>每一次切分选择的基准数字刚好将当前序列等分。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220928220824834.png" alt="image-20220928220824834"></p>
<p> 如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了logn次，所以，==<strong>最优情况下快速排序的时间复杂度为O(nlogn);</strong>==</p>
<p><strong>最坏情况：</strong>每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以，最坏情况下，快速排序的==<strong>时间复杂度为O(n^2);</strong>==</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220928221247408.png" alt="image-20220928221247408"></p>
<p><strong>平均情况：</strong>每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证明，快速排序的==<strong>时间复杂度为O(nlogn)</strong>==,由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对平均情况的时间复杂度做证明了。</p>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a><strong>排序的稳定性</strong></h2><p><strong>稳定性的定义：</strong></p>
<p>数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220928231010283.png" alt="image-20220928231010283"></p>
<p><strong>稳定性的意义：</strong></p>
<p>如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h4 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h4><p>只有当arr[i]&gt;arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种==<strong>稳定排序算法</strong>==。</p>
<h4 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序:"></a>选择排序:</h4><p>选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2，所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种==<strong>不稳定的排序算法</strong>==。</p>
<h4 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h4><p>比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以==<strong>插入排序是稳定</strong>的==。</p>
<h4 id="希尔排序："><a href="#希尔排序：" class="headerlink" title="希尔排序："></a>希尔排序：</h4><p>希尔排序是按照不同步长对元素进行插入排序 ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔==<strong>排序是不稳定的</strong>==。</p>
<h4 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h4><p>归并排序在归并的过程中，只有arr[i]&lt;arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，==<strong>归并排序是稳定的</strong>==。</p>
<h4 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h4><p>快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以==<strong>快速排序是一种不稳定的算法</strong>==。</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是最基本、最简单、也是最常用的一种数据结构。一个==<strong>线性表是n个具有相同特性的数据元素的有限序列</strong>==。</p>
<p><strong>前驱元素：</strong></p>
<p>​		若A元素在B元素的前面，则称A为B的前驱元素</p>
<p><strong>后继元素：</strong></p>
<p>​		若B元素在A元素的后面，则称B为A的后继元素</p>
<p><strong>线性表的特征：</strong>数据元素之间具有一种“一对一”的逻辑关系。</p>
<ul>
<li>第一个数据元素没有前驱，这个数据元素被称为头结点；</li>
<li>最后一个数据元素没有后继，这个数据元素被称为尾结点；</li>
<li>除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。</li>
</ul>
<p>如果把线性表用数学语言来定义，则可以表示为(a1,…ai-1,ai,ai+1,…an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai的后继元素</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220928233629886.png" alt="image-20220928233629886"></p>
<p><strong>线性表的分类：</strong></p>
<p>线性表中数据<strong>存储的方式</strong>可以是==<strong>顺序存储</strong>==，也可以是==<strong>链式存储</strong>==，按照数据的存储方式不同，可以把<strong>线性表</strong>分为==<strong>顺序表</strong>和<strong>链表</strong>==。</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p><strong>定义：</strong>顺序表是在计算机内存中以==<strong>数组的形式保存</strong>==的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220928234101456.png" alt="image-20220928234101456"></p>
<h4 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a><strong>顺序表的实现</strong></h4><h5 id="顺序表API设计："><a href="#顺序表API设计：" class="headerlink" title="顺序表API设计："></a>顺序表API设计：</h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>SequenceList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SequenceList(int capacity)：创建容量为capacity的SequenceList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public void clear()：空置线性表                                                                                                                                                                                                           2、public boolean isEmpty()：判断线性表是否为空，是返回true，否返回                                                                                                                                    3、public int length():获取线性表中元素的个数                                                                                                                                                                                        4、public T get(int i):读取并返回线性表中的第i个元素的值                                                                                                                                                                5、public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。                                                                                                                     6、public void insert(T t):向线性表中添加一个元素t                                                                                                                                                                              7、public T remove(int i):删除并返回线性表中第i个数据元素。                                                                                                                                                               8、public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private T[] eles：存储元素的数组                                                                                                                                                                                                            2、private int N:当前线性表的长度</td>
</tr>
</tbody></table>
<h5 id="顺序表的代码实现："><a href="#顺序表的代码实现：" class="headerlink" title="顺序表的代码实现："></a><strong>顺序表的代码实现：</strong></h5><p><strong>SequenceList类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SequenceList &lt;T&gt;{

    private T[] eles; //存储元素的数组
    private int N;  //当前线性表的长度

    public SequenceList(int capacity) {
        this.eles = (T[])new Object[capacity]; //初始化数组
        this.N = 0;  //初始化数组长度
    }

    //将线性表置空
    public void clear(){
        this.N = 0;
    }

    //判断线性表是否为空，是返回true，否返回
    public boolean isEmpty(){
        return N == 0;
    }


    //获取线性表中元素的个数
    public int length(){
        return N;
    }

    //读取并返回线性表中的第i个元素的值
    public T get(int i){
        return eles[i];
    }


    //在线性表的第i个元素之前插入一个值为t的数据元素。
    public void insert(int i,T t){
        //先把i索引及其后面的元素依次向后移动一位
        for (int index = N - 1; index &gt; i ; index--) {
            eles[index] = eles[index-1];
        }

        //再把t元素放到i索引处即可
        eles[i] = t;
    }

    //向线性表中添加一个元素t
    public void insert(T t){
        eles[N++] = t;
    }

    //删除并返回线性表中第i个数据元素。
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];

        //索引i后面的元素向前移一位即可
        for (int index = i; index &lt; N - 1; index++) {
            eles[index] = eles[index+1];
        }

        //删除元素后数组长度减1
        N--;
        return current;
    }

    //返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。
    public int indexOf(T t){
        for (int i = 0; i &lt; N; i++) {
            if (eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>测试类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SequenceListTest {
    public static void main(String[] args) {
        //创建顺序表对象
        SequenceList&lt;String&gt; list = new SequenceList&lt;&gt;(10);

        //测试插入
        list.insert("科比");
        list.insert("詹姆斯");
        list.insert("乔丹");
        list.insert("库里");


        //测试获取
        String s = list.get(2);
        System.out.println("获取索引为2处的值："+ s);

        //测试删除
        String remove = list.remove(3);
        System.out.println("删除索引为3处的值："+ remove);


        //测试清空
        list.clear();
        System.out.println("清空线性表后线性表的元素个数有多少个"+ list.length());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="顺序表的遍历"><a href="#顺序表的遍历" class="headerlink" title="顺序表的遍历"></a><strong>顺序表的遍历</strong></h4><p>一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。</p>
<p>在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则</p>
<p><strong>需要做如下操作：</strong></p>
<p> 1、让SequenceList实现Iterable接口，重写iterator方法；</p>
<p> 2、在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；</p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>SequenceList类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SequenceList &lt;T&gt; implements Iterable&lt;T&gt;{

    private T[] eles; //存储元素的数组
    private int N;  //当前线性表的长度

    public SequenceList(int capacity) {
        this.eles = (T[])new Object[capacity]; //初始化数组
        this.N = 0;  //初始化数组长度
    }

    //将线性表置空
    public void clear(){
        this.N = 0;
    }

    //判断线性表是否为空，是返回true，否返回
    public boolean isEmpty(){
        return N == 0;
    }


    //获取线性表中元素的个数
    public int length(){
        return N;
    }

    //读取并返回线性表中的第i个元素的值
    public T get(int i){
        return eles[i];
    }


    //在线性表的第i个元素之前插入一个值为t的数据元素。
    public void insert(int i,T t){
        //先把i索引及其后面的元素依次向后移动一位
        for (int index = N; index &gt; i ; index--) {
            eles[index] = eles[index-1];
        }

        //再把t元素放到i索引处即可
        eles[i] = t;

        //添加元素后数组长度+1
        N++;
    }

    //向线性表中添加一个元素t
    public void insert(T t){
        eles[N++] = t;
    }

    //删除并返回线性表中第i个数据元素。
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];

        //索引i后面的元素向前移一位即可
        for (int index = i; index &lt; N - 1; index++) {
            eles[index] = eles[index+1];
        }

        //删除元素后数组长度减1
        N--;
        return current;
    }

    //返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。
    public int indexOf(T t){
        for (int i = 0; i &lt; N; i++) {
            if (eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }

    @Override
    public Iterator iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{

        private int cusor;

        public SIterator() {
            this.cusor = 0;
        }

        @Override
        public boolean hasNext() {
            return cusor &lt; N;
        }

        @Override
        public Object next() {
            return eles[cusor++];
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>测试类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SequenceListTest {
    public static void main(String[] args) {
        //创建顺序表对象
        SequenceList&lt;String&gt; list = new SequenceList&lt;&gt;(10);

        //测试插入
        list.insert("科比");
        list.insert("詹姆斯");
        list.insert("乔丹");
        list.insert(1,"库里");

        for (String s : list) {
            System.out.println(s);
        }

        System.out.println("===========================================");
        //测试获取
        String s = list.get(2);
        System.out.println("获取索引为2处的值："+ s);

        //测试删除
        String remove = list.remove(3);
        System.out.println("删除索引为3处的值："+ remove);


        //测试清空
        list.clear();
        System.out.println("清空线性表后线性表的元素个数有多少个"+ list.length());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220929003143957.png" alt="image-20220929003143957"></p>
<h4 id="顺序表的容量可变（扩容）"><a href="#顺序表的容量可变（扩容）" class="headerlink" title="顺序表的容量可变（扩容）"></a><strong>顺序表的容量可变</strong>（扩容）</h4><p><strong>1.添加元素时：</strong></p>
<p>添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们这里创建一个是原数组两倍容量的新数组存储元素。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220929224444878.png" alt="image-20220929224444878"></p>
<p><strong>2.移除元素时：</strong></p>
<p>移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建一个是原数组容量的1/2的新数组存储元素。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220929224720027.png" alt="image-20220929224720027"></p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SequenceList &lt;T&gt; implements Iterable&lt;T&gt;{

    private T[] eles; //存储元素的数组
    private int N;  //当前线性表的长度

    public SequenceList(int capacity) {
        this.eles = (T[])new Object[capacity]; //初始化数组
        this.N = 0;  //初始化数组长度
    }

    //将线性表置空
    public void clear(){
        this.N = 0;
    }

    //判断线性表是否为空，是返回true，否返回
    public boolean isEmpty(){
        return N == 0;
    }


    //获取线性表中元素的个数
    public int length(){
        return N;
    }

    //读取并返回线性表中的第i个元素的值
    public T get(int i){
        return eles[i];
    }


    //在线性表的第i个元素之前插入一个值为t的数据元素。
    public void insert(int i,T t){
        if (N == eles.length){
            reSzie(2* eles.length);
        }

        //先把i索引及其后面的元素依次向后移动一位
        for (int index = N; index &gt; i ; index--) {
            eles[index] = eles[index-1];
        }

        //再把t元素放到i索引处即可
        eles[i] = t;

        //添加元素后数组长度+1
        N++;
    }

    //向线性表中添加一个元素t
    public void insert(T t){
        if (N == eles.length){
            reSzie(2* eles.length);
        }
        eles[N++] = t;
    }

    //删除并返回线性表中第i个数据元素。
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];

        //索引i后面的元素向前移一位即可
        for (int index = i; index &lt; N - 1; index++) {
            eles[index] = eles[index+1];
        }

        //删除元素后数组长度减1
        N--;
        if (N &lt; eles.length/4){
            reSzie(eles.length/2);
        }
        return current;
    }

    //返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。
    public int indexOf(T t){
        for (int i = 0; i &lt; N; i++) {
            if (eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }

    //数组扩容(根据参数newSize，来重置eles的大小)
    public void reSzie(int newSize){

        //定义一个临时数组，指向原数组
        T[] temp = eles;

        //创建新数组
        eles = (T[]) new Object[newSize];

        //把原数组的内容拷贝到新数组
        for (int i = 0; i &lt; N; i++) {
            eles[i] = temp[i];
        }
    }

    @Override
    public Iterator iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{

        private int cusor;

        public SIterator() {
            this.cusor = 0;
        }

        @Override
        public boolean hasNext() {
            return cusor &lt; N;
        }

        @Override
        public Object next() {
            return eles[cusor++];
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="顺序表的时间复杂度"><a href="#顺序表的时间复杂度" class="headerlink" title="顺序表的时间复杂度"></a><strong>顺序表的时间复杂度</strong></h4><p><strong>get(i)：</strong>不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以==<strong>时间复杂度为O(1)</strong>==;</p>
<p><strong>insert(int i,T t)：</strong>每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，==<strong>时间复杂为O(n)</strong>==;</p>
<p><strong>remove(int i)：</strong>每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，==<strong>时间复杂度为O(n);</strong>==</p>
<p>由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显</p>
<h4 id="java中ArrayList实现"><a href="#java中ArrayList实现" class="headerlink" title="java中ArrayList实现"></a>java中ArrayList实现</h4><p>java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。</p>
<p>1.是否用数组实现；</p>
<p>2.有没有扩容操作；</p>
<p>3.有没有提供遍历方式；</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>之前我们已经使用顺序存储结构实现了线性表，我们会发现虽然顺序表的查询很快，时间复杂度为O(1),但是增删的效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。这个问题有没有解决方案呢？有，我们可以使用另外一种存储结构实现线性表，链式存储结构。</p>
<p>链表是一种==<strong>物理存储单元上非连续、非顺序的存储结构</strong>==，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<strong>链表由一系列的结点（链表中的每一个元素称为结点）组成</strong>，结点可以在运行时动态生成。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220929230557252.png" alt="image-20220929230557252"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220929230706282.png" alt="image-20220929230706282"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220929230831445.png" alt="image-20220929230831445"></p>
<h4 id="结点API设计："><a href="#结点API设计：" class="headerlink" title="结点API设计："></a>结点API设计：</h4><table>
<thead>
<tr>
<th>类名</th>
<th>Node<t></t></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item:存储数据                                                                                                                                                                                                                                                     Node next：指向下一个结点</td>
</tr>
</tbody></table>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Node &lt;T&gt;{
    private T item; //存储数据
    public Node next; //指向下一个结点

    public Node(T item, Node next) {
        this.item = item;
        this.next = next;
    }

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="生成链表"><a href="#生成链表" class="headerlink" title="生成链表"></a>生成链表</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class NodeTest {
    public static void main(String[] args) {
        //构建结点
        Node&lt;Integer&gt; first = new Node&lt;&gt;(11, null);
        Node&lt;Integer&gt; second = new Node&lt;&gt;(13, null);
        Node&lt;Integer&gt; third = new Node&lt;&gt;(14, null);
        Node&lt;Integer&gt; fourth = new Node&lt;&gt;(12, null);
        Node&lt;Integer&gt; fifth = new Node&lt;&gt;(9, null);

        //生成链表
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><p>单向链表是链表的一种，它由多个结点组成，==<strong>每个结点都由一个数据域和一个指针域组成</strong>==，<strong>数据域用来存储数据</strong>，<strong>指针域用来指向其后继结点</strong>。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220929232121833.png" alt="image-20220929232121833"></p>
<h5 id="单项链表的API设计"><a href="#单项链表的API设计" class="headerlink" title="单项链表的API设计"></a>单项链表的API设计</h5><table>
<thead>
<tr>
<th>类名</th>
<th><strong>LinkList＜Ｔ＞</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>LinkList()：创建LinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public void clear()：空置线性表 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2、public　boolean isEmpty()：判断线性表是否为空，是返回true，否返回false　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　3、public int length():　获取线性表中元素的个数　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　4、public T get(int i):　读取并返回线性表中的第i个元素的值　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　5、public void insert(T t)：往线性表中添加一个元素　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　6、public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　7、public T remove(int i):　删除并返回线性表中第i个数据元素　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　8、public int indexOf(T t):　返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</td>
</tr>
<tr>
<td>成员内部</td>
<td>private class Node:　结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private Node head:记录首结点　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2、private int N:记录链表的长度</td>
</tr>
</tbody></table>
<h5 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>LinkList</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkList &lt;T&gt; implements Iterable{
    //头结点
    private Node head;

    //记录链表的长度
    private int N;


    public LinkList() {
        //初始化头结点
        this.head = new Node(null,null);

        //初始化元素的个数
        this.N = 0;
    }

    //清空链表
    public void clear(){
        head.next = null;
        this.N = 0;
    }

    //判断线性表是否为空，是返回true，否返回false　
    public boolean isEmpty(){
        return  N == 0;
    }

    //获取线性表中元素的个数
    public int length(){
        return N;
    }

    //读取并返回线性表中的第i个元素的值
    public T get(int i){
        //通过循环，从头结点开始往后找，找i次，就可以找到该元素
        Node n = head.next;
        for (int index = 0; index &lt; i; index++) {
            n = n.next;
        }
        return (T) n.item;
    }

    //往线性表中添加一个元素
    public void insert(T t){
        //先找到当前的结点
        Node n = head;
        while (n.next != null) {
            n = n.next;
        }

        //创建新的结点，保存元素
        Node&lt;T&gt; tNode = new Node&lt;&gt;(t, null);

        //让当前的最后一个结点指向新的结点
        n.next = tNode;

        //元素的个数+1
        N++;
    }

    //在线性表的第i个元素之前插入一个值为t的数据元素。
    public void insert(int i,T t){
        // 先找到当前的结点的前一个结点
        Node pre = head;
        for (int index = 0; index &lt; i - 1; index++) {
            pre = pre.next;
        }

        //找到i位置的结点
        Node curr = pre.next;

        //创建新的结点，并且新的结点需要指向原来i的位置的结点
        Node&lt;T&gt; tNode = new Node&lt;&gt;(t, curr);

        //原理i位置的前一个结点指向新的结点即可
        pre.next = tNode;

        //元素的个数+1
        N++;
    }

    //删除并返回线性表中第i个数据元素
    public T remove(int i){
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index &lt;= i - 1; index++) {
            pre = pre.next;
        }

        //找到当前i位置的结点
        Node curr = pre.next;

        //找到i位置的下一个结点
        Node nextNode = curr.next;

        //前一个结点指向下一个结点
        pre.next = nextNode;

        //元素的个数+1
        N--;
        return (T) curr.item;
    }

    //返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1
    public int indexOf(T t){
        //从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，则说明找到，否则就没有该元素
        Node n = head;
        for (int i = 0; n.next != null ; i++) {
            n = n.next;
            if (n.item.equals(t)){
                return i;
            }
        }
        return -1;
    }

    private class LIterator&lt;T&gt; implements Iterator{
        private Node n;

        public LIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {

            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }

    @Override
    public Iterator iterator() {
        return new LIterator();
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>测试类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkListTest {
    public static void main(String[] args) {
        //创建单项链表对象
        LinkList&lt;String&gt; list = new LinkList&lt;&gt;();

        //测试插入
        list.insert("科比");
        list.insert("詹姆斯");
        list.insert("乔丹");
        list.insert(1,"库里");

        for (Object s : list) {
            System.out.println(s);
        }

        System.out.println("===========================================");
        //测试获取
        String s = list.get(2);
        System.out.println("获取索引为2处的值："+ s);

        //测试删除
        String remove = list.remove(3);
        System.out.println("删除索引为3处的值："+ remove);


        //测试清空
        list.clear();
        System.out.println("清空线性表后线性表的元素个数有多少个"+ list.length());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930002855854.png" alt="image-20220930002855854"></p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表也叫双向表，是链表的一种，它由多个结点组成，==<strong>每个结点都由一个数据域和两个指针域组成</strong>==，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930094231021.png" alt="image-20220930094231021"></p>
<p>按照面向对象的思想，我们需要设计一个类，来描述结点这个事物。由于结点是属于链表的，所以我们把结点类作为链表类的一个内部类来实现</p>
<h5 id="结点API设计"><a href="#结点API设计" class="headerlink" title="结点API设计"></a>结点API设计</h5><table>
<thead>
<tr>
<th>类名</th>
<th>Node<t></t></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node pre,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item: 存储数据                                                                                                                                                                                                                                                     Node next：指向下一个结点                                                                                                                                                                                                                        Node pre: 指向上一个结点</td>
</tr>
</tbody></table>
<h5 id="双向链表API设计"><a href="#双向链表API设计" class="headerlink" title="双向链表API设计"></a>双向链表API设计</h5><table>
<thead>
<tr>
<th>类名</th>
<th><strong>TowWayLinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>TowWayLinkList()：创建TowWayLinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public void clear()：空置线性表                                                                                                                                                                                               2、public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false                                                                                                                                             3、public int length(): 获取线性表中元素的个数                                                                                                                                                                                            4、public T get(int i): 读取并返回线性表中的第i个元素的值                                                                                                                                                                      5、public void insert(T t)：往线性表中添加一个元素                                                                                                                                                                           6、public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。                                                                                                                       7、public T remove(int i): 删除并返回线性表中第i个数据元素                                                                                                                                                          8、public int indexOf(T t): 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1                                                                                            9、public T getFirst(): 获取第一个元素                                                                                                                                                                                                  10、public T getLast(): 获取最后一个元素</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node: 结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private Node first: 记录首结点                                                                                                                                                                                                                   2、private Node last: 记录尾结点                                                                                                                                                                                                              3、private int N: 记录链表的长度</td>
</tr>
</tbody></table>
<h5 id="双向链表代码实现"><a href="#双向链表代码实现" class="headerlink" title="双向链表代码实现"></a><strong>双向链表代码实现</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt;{

    //首结点
    private Node head;

    //最后一个结点
    private Node last;

    //记录链表的长度
    private int N;

    //结点类
    private class Node{
        public T item; //存储数据
        public Node pre; //指向上一个结点
        public Node next; //指向下一个结点
        public Node(T item,Node pre,Node next){
            this.item = item;
            this.pre = pre;
            this.next = next;
        }
    }


    public TowWayLinkList() {
        //初始化头结点
        this.head = new Node(null,null,null);

        //初始化尾节点
        this.last = null;

        //初始化元素的个数
        this.N = 0;
    }

    //清空链表
    public void clear(){

        this.head.next = null;
        this.head.item = null;
        this.head.pre = null;
        this.last = null;
        this.N = 0;
    }

    //判断线性表是否为空，是返回true，否返回false　
    public boolean isEmpty(){
        return  N == 0;
    }

    //获取线性表中元素的个数
    public int length(){
        return N;
    }

    // 获取第一个元素
    public T getFirst() {
        if (isEmpty()){
            return null;
        }
        return head.next.item;
    }

    // 获取最后一个元素
    public T getLast() {
        if (isEmpty()){
            return null;
        }
        return last.item;
    }

    //读取并返回线性表中的第i个元素的值
    public T get(int i){
        //通过循环，从头结点开始往后找，找i次，就可以找到该元素
        Node n = head.next;
        for (int index = 0; index &lt; i; index++) {
            n = n.next;
        }
        return n.item;
    }

    //往线性表中添加一个元素
    public void insert(T t){
        //判断链表是否为空
        if(isEmpty()){
            //创建新的结点
            Node newNode = new Node(t, head, null);

            //让新的结点指向尾结点
            last = newNode;

            //让头结点指向尾结点
            head.next = last;

        }else {
            Node oldLast = last;

            //创建新的结点
            Node newNode = new Node(t, oldLast, null);

            //让当前的尾结点指向新的结点
            oldLast.next = newNode;

            //让新的结点成为尾结点
            last = newNode;

        }

        //元素的个数+1
        N++;
    }

    //在线性表的第i个元素之前插入一个值为t的数据元素。
    public void insert(int i,T t){
        // 先找到当前的结点的前一个结点
        Node pre = head;
        for (int index = 0; index &lt; i - 1; index++) {
            pre = pre.next;
        }

        //找到i位置的结点
        Node curr = pre.next;

        //创建新的结点，并且新的结点需要指向原来i的位置的结点
        Node tNode = new Node(t, pre,curr);

        //让i位置的下一个结点成为新的结点即可
        pre.next = tNode;

        //让i位置的前一个结点成为新的结点即可
        curr.pre = tNode;

        //元素的个数+1
        N++;
    }

    //删除并返回线性表中第i个数据元素
    public T remove(int i){
        //找到i位置的前一个结点
        Node pre = head;
        for (int index = 0; index &lt; i; index++) {
            pre = pre.next;
        }

        //找到当前i位置的结点
        Node curr = pre.next;

        //找到i位置的下一个结点
        Node nextNode = curr.next;

        //前一个结点指向下一个结点头结点
        pre.next = nextNode;

        //下一个结点指向前一个结点尾结点
        nextNode.pre = pre;

        //元素的个数+1
        N--;
        return  curr.item;
    }

    //返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1
    public int indexOf(T t){
        //从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，则说明找到，否则就没有该元素
        Node n = head;
        for (int i = 0; n.next != null ; i++) {
            n = n.next;
            if (n.item.equals(t)){
                return i;
            }
        }
        return -1;
    }

    private class LIterator&lt;T&gt; implements Iterator {
        private Node n;

        public LIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {

            return n.next != null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }

    @Override
    public Iterator iterator() {
        return new LIterator();
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TowWayLinkListTest {
    public static void main(String[] args) {
        //创建顺序表对象
        TowWayLinkList&lt;String&gt; list = new TowWayLinkList&lt;&gt;();

        //测试插入
        list.insert("科比");
        list.insert("詹姆斯");
        list.insert("乔丹");
        list.insert(1,"库里");

        for (String s : list) {
            System.out.println(s);
        }

        System.out.println("===========================================");
        //测试获取
        String s = list.get(2);
        System.out.println("获取索引为2处的值："+ s);

        System.out.println("==========================");
        //测试删除
        String remove = list.remove(2);
        System.out.println("删除索引为2处的值："+ remove);
        System.out.println("第一个元素处的值："+ list.getFirst());
        System.out.println("最后一个元素为处的值："+ list.getLast());



        //测试清空
        list.clear();
        System.out.println("清空线性表后线性表的元素个数有多少个:"+ list.length());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930130431464.png" alt="image-20220930130431464"></p>
<h5 id="java中LinkedList实现"><a href="#java中LinkedList实现" class="headerlink" title="java中LinkedList实现"></a>java中LinkedList实现</h5><p>java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法</p>
<p>1.底层是否用双向链表实现；</p>
<p>2.结点类是否有三个域</p>
<h5 id="链表的复杂度分析"><a href="#链表的复杂度分析" class="headerlink" title="链表的复杂度分析"></a><strong>链表的复杂度分析</strong></h5><p><strong>get(int i):</strong>	每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，==<strong>时间复杂度为O(n)</strong>==</p>
<p><strong>insert(int i,T t):</strong>	每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，==<strong>时间复杂度为O(n);</strong>==</p>
<p><strong>remove(int i):</strong>	每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，==<strong>时间复杂度为O(n)</strong>==</p>
<p>相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,,同时它并没有涉及的元素的交换。</p>
<p>相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。</p>
<h4 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a><strong>链表反转</strong></h4><p>单链表的反转，是面试中的一个高频题目。</p>
<p><strong>需求：</strong></p>
<p>原链表中数据为：1-&gt;2-&gt;3&gt;4</p>
<p>反转后链表中数据为：4-&gt;3-&gt;2-&gt;1</p>
<p><strong>反转API：</strong></p>
<p><code>public void reverse()：对整个链表反转 </code></p>
<p><code>public Node reverse(Node curr)：反转链表中的某个结点curr,并把反转后的curr结点返回</code></p>
<p>使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点，直到把最后一个结点反转完毕，整个链表就反转完毕。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930131632237.png" alt="image-20220930131632237"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h5><p>在LinkList类（单链表）添加如下的代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//单链表的反转
    public void reverse(){
        //先判断链表是否为空
        if (isEmpty()){
            return;
        }
        reverse(head.next);
    }

    //反转指定的结点，并把反转后的结点返回
    public Node reverse(Node curr){
        //如果当前的结点为空，直接返回
        if (curr.next == null){
            head.next = curr;
            return curr;
        }
        //递归的反转当前的结点curr的下一个结点，返回值就是链表反转后当前结点的上一个结点
        Node pre = reverse(curr.next);

        //让反转后的结点的下一结点变为当前的结点curr
        pre.next = curr;

        //把当前的结点的下一结点变为null
        curr.next = null;
        return curr;

    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkListTest01 {
    public static void main(String[] args) {
        //创建单项链表对象
        LinkList&lt;String&gt; list = new LinkList&lt;&gt;();

        //测试插入
        list.insert("科比");
        list.insert("詹姆斯");
        list.insert("乔丹");
        list.insert(1,"库里");


        System.out.println("反转前：");

        for (Object s : list) {
            System.out.println(s);
        }

        System.out.println("===========================================");


        System.out.println("反转后：");
        list.reverse();
        for (Object s : list) {
            System.out.println(s);
        }

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930152447473.png" alt="image-20220930152447473"></p>
<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以让我们找到链表上相应的结点。一般情况下，<strong>快指针的移动步长为慢指针的两倍</strong></p>
<h5 id="中间值问题"><a href="#中间值问题" class="headerlink" title="中间值问题"></a><strong>中间值问题</strong></h5><p><strong>需求：</strong></p>
<p>请完善测试类Test中的getMid方法，可以找出链表的中间元素值并返回。</p>
<p>利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以此来达到找到中间节点的目的。</p>
<p>如下图，最开始，slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930153010663.png" alt="image-20220930153010663"></p>
<h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FastSlowTest {
    public static void main(String[] args) {
        Node&lt;String&gt; first = new Node&lt;&gt;("aa", null);
        Node&lt;String&gt; second = new Node&lt;&gt;("bb", null);
        Node&lt;String&gt; third = new Node&lt;&gt;("gg", null);
        Node&lt;String&gt; fourth = new Node&lt;&gt;("cc", null);
        Node&lt;String&gt; fifth = new Node&lt;&gt;("dd", null);
        Node&lt;String&gt; six = new Node&lt;&gt;("ee", null);
        Node&lt;String&gt; seven = new Node&lt;&gt;("ff", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;

        //查找中间值
       String mid = getMid(first);
        System.out.println("中间值为："+mid);

    }

    /**
     *
     * @param first  链表的首结点
     * @return  链表的中间结点的值
     */
    public static String  getMid(Node&lt;String&gt; first){
        Node&lt;String&gt; slow = first; //慢指针
        Node&lt;String&gt; fast = first; //快指针

        //使用两个指针强历链表,快指针指向的结点没有下一个结点了,就可以结束了,结束之后,慢指针指向的结点就是中间值
        while(fast!=null &amp;&amp; fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        return slow.item;
    }


    private static class Node&lt;T&gt;{
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next){
            this.item = item;
            this.next = next;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930154833330.png" alt="image-20220930154833330"></p>
<h5 id="单向链表是否有环问题"><a href="#单向链表是否有环问题" class="headerlink" title="单向链表是否有环问题"></a><strong>单向链表是否有环问题</strong></h5><p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930155006707.png" alt="image-20220930155006707"></p>
<p><strong>需求：</strong></p>
<p>请完善测试类Test中的isCircle方法，返回链表中是否有环。</p>
<p>使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930155705883.png" alt="image-20220930155705883"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930155750653.png" alt="image-20220930155750653"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930155835194.png" alt="image-20220930155835194"></p>
<h6 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CircleListCheckTest {
    public static void main(String[] args) {
        Node&lt;String&gt; first = new Node&lt;&gt;("aa", null);
        Node&lt;String&gt; second = new Node&lt;&gt;("bb", null);
        Node&lt;String&gt; third = new Node&lt;&gt;("gg", null);
        Node&lt;String&gt; fourth = new Node&lt;&gt;("cc", null);
        Node&lt;String&gt; fifth = new Node&lt;&gt;("dd", null);
        Node&lt;String&gt; six = new Node&lt;&gt;("ee", null);
        Node&lt;String&gt; seven = new Node&lt;&gt;("ff", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;

        //生成环
        seven.next = third;

        //判断链表是否有环
        boolean circle = isCircle(first);
        System.out.println("first链表中是否有环？"+ circle);


    }

    public static boolean isCircle(Node&lt;String&gt; first){
        Node&lt;String&gt; slow = first;
        Node&lt;String&gt; fast = first;

        //遍历链表﹐如果快慢指针指向了同一个结点﹐那么证明有环
        while(fast!=null &amp;&amp; fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
            if (fast.equals(slow)){
                return true;
            }
        }
        return false;
    }

   
    private static class Node&lt;T&gt;{
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next){
            this.item = item;
            this.next = next;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930160518106.png" alt="image-20220930160518106"></p>
<h5 id="有环链表入口问题"><a href="#有环链表入口问题" class="headerlink" title="有环链表入口问题"></a><strong>有环链表入口问题</strong></h5><p><strong>需求：</strong></p>
<p>完善Test类中的getEntrance方法，查找有环链表中环的入口结点。</p>
<p>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。证明这一结论牵涉到数论的知识，这里略，只讲实现。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930160642311.png" alt="image-20220930160642311"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930160823740.png" alt="image-20220930160823740"></p>
<h6 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CircleListCheckTest {
    public static void main(String[] args) {
        Node&lt;String&gt; first = new Node&lt;&gt;("aa", null);
        Node&lt;String&gt; second = new Node&lt;&gt;("bb", null);
        Node&lt;String&gt; third = new Node&lt;&gt;("gg", null);
        Node&lt;String&gt; fourth = new Node&lt;&gt;("cc", null);
        Node&lt;String&gt; fifth = new Node&lt;&gt;("dd", null);
        Node&lt;String&gt; six = new Node&lt;&gt;("ee", null);
        Node&lt;String&gt; seven = new Node&lt;&gt;("ff", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;

        //生成环
        seven.next = third;

        //判断链表是否有环
        boolean circle = isCircle(first);
        System.out.println("first链表中是否有环？"+ circle);

        //查找环的入口
        Node entrance = getEntrance(first);
        System.out.println("fisrt链表中环的入口是:"+ entrance.item);


    }

    public static Node getEntrance(Node&lt;String&gt; first){
        Node&lt;String&gt; slow = first;
        Node&lt;String&gt; fast = first;
        Node&lt;String&gt; temp = null; //临时指针

        //遍历链表，先找到环（快慢指针相遇），准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇的位置就是环的入口
        while(fast!=null &amp;&amp; fast.next!=null){
            fast = fast.next.next;
            slow=slow.next;

            //判断快慢指针是否相遇
            if (fast.equals(slow)){
                temp = first;
                continue;
            }
            //让临时结点变换
            if (temp!=null){
                temp=temp.next;
                //判断临时指针与慢指针是否相遇
                if (temp.equals(slow)){
                    break;
                }
            }
        }
        return temp;
    }

    public static boolean isCircle(Node&lt;String&gt; first){
        Node&lt;String&gt; slow = first;
        Node&lt;String&gt; fast = first;

        //遍历链表﹐如果快慢指针指向了同一个结点﹐那么证明有环
        while(fast!=null &amp;&amp; fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
            if (fast.equals(slow)){
                return true;
            }
        }
        return false;
    }

   


    private static class Node&lt;T&gt;{
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next){
            this.item = item;
            this.next = next;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a><strong>循环链表</strong></h4><p>循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930200032818.png" alt="image-20220930200032818"></p>
<h5 id="循环列表的构建"><a href="#循环列表的构建" class="headerlink" title="循环列表的构建"></a>循环列表的构建</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CircleListCheckTest {
    public static void main(String[] args) {
        Node&lt;String&gt; first = new Node&lt;&gt;("aa", null);
        Node&lt;String&gt; second = new Node&lt;&gt;("bb", null);
        Node&lt;String&gt; third = new Node&lt;&gt;("gg", null);
        Node&lt;String&gt; fourth = new Node&lt;&gt;("cc", null);
        Node&lt;String&gt; fifth = new Node&lt;&gt;("dd", null);
        Node&lt;String&gt; six = new Node&lt;&gt;("ee", null);
        Node&lt;String&gt; seven = new Node&lt;&gt;("ff", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;

        //构建循环链表,让最后一个结点指向第一个结点
        seven.next = first;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a><strong>约瑟夫问题</strong></h4><p><strong>问题描述：</strong></p>
<p>传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。</p>
<p><strong>问题转换：</strong></p>
<p>41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。</p>
<p>1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；</p>
<p>2.自退出那个人开始的下一个人再次从1开始报数，以此类推；</p>
<p>3.求出最后退出的那个人的编号。</p>
<p><strong>图示：</strong></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930200702147.png" alt="image-20220930200702147"></p>
<p>  <strong>解题思路：</strong></p>
<p>1.构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；</p>
<p>2.使用计数器count，记录当前报数的值；</p>
<p>3.遍历链表，每循环一次，count++；</p>
<p>4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；</p>
<h5 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JosephTest {
    public static void main(String[] args) {

        //解决约瑟夫问题

        //1.构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；
        Node&lt;Integer&gt; first = null; //首结点
        Node&lt;Integer&gt; pre = null;  //记录前一个结点

        for (int i = 1; i &lt;= 41; i++) {
            //如果是第一个结点
            if (i == 1){
                first = new Node&lt;&gt;(i,null);
                pre = first;
                continue;
            }

            //如果不是第一个结点
            Node&lt;Integer&gt; newNode = new Node&lt;&gt;(i,null);
            pre.next = newNode;
            pre = newNode;

            //如果是最后一个结点，那么需要让最后一个结点的下一个结点变为first，变为循环链表
            if (i == 41){
                pre.next = first;
            }

        }

        //2.使用计数器count，记录当前报数的值；
        int count = 0;

        //3.遍历循环列表

        Node&lt;Integer&gt; n = first; //记录每次遍历拿到的结点，默认从首结点开始
        Node&lt;Integer&gt; before = null;  //记录当前结点的上一个结点

        while (n != n.next){
            //模拟报数
            count++;
            //判断当前报数是否是3
            if (count == 3){
                //如果是3﹔则把当前结点删除调用﹔打印当前结点,重置count=0,让当前结点n后移

                before.next = n.next;
                System.out.print(n.item + "\t");
                count = 0; //重置报数
                n = n.next; //指针向下移
            }else {
                //如果不是3: ifbefore变为当前结点﹔让当前结点后移;

                before = n;
                n = n.next;
            }
        }
        System.out.println(n.item);
    }


    //结点类
    private static class Node&lt;T&gt;{
        //存储数据
        T item;
        //下一个结点
        Node next;
        public Node(T item, Node next){
            this.item = item;
            this.next = next;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>计算机中的栈</strong></p>
<p>我们把生活中的栈的概念引入到计算机中，就是供数据休息的地方，它是一种数据结构，数据既可以进入到栈中，又可以从栈中出去。</p>
<p>栈是一种基于==<strong>先进后出(FILO)</strong>==的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</p>
<p>我们称数据进入到栈的动作为<strong>压栈</strong>，数据从栈中出去的动作为<strong>弹栈</strong>。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220930204328922.png" alt="image-20220930204328922"></p>
<h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a><strong>栈的实现</strong></h4><h5 id="栈API设计"><a href="#栈API设计" class="headerlink" title="栈API设计"></a><strong>栈API设计</strong></h5><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Stack</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Stack)：创建Stack对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public boolean isEmpty()：判断栈是否为空，是返回true，否返回false                                                                                                                                  2、public int size():  获取栈中元素的个数                                                                                                                                                                                                                                                    3、public T pop():  弹出栈顶元素                                                                                                                                                                                                          4、public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private Node head:  记录首结点                                                                                                                                                                                                          2、private int N:  当前栈的元素个数</td>
</tr>
</tbody></table>
<h5 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Stack &lt;T&gt; implements Iterable&lt;T&gt;{
    private Node head;  //首结点

    private int N; //栈的长度


    //结点类
    private class Node{
        public T item; //存储数据
        public Node next; //指向下一个结点

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    //初始化栈
    public Stack(){
        this.head = new Node(null,null);
        this.N = 0;
    }

    //判断栈是否为空
    public boolean isEmpty(){
        return N == 0;
    }

    //获取栈中元素的个数
    public int size(){
        return N;
    }

    //把元素t压栈
    public  void push(T t){
        //找到首结点指向的第一个结点
        Node oldFirst = head.next;

        //创建新的结点
        Node newNode = new Node(t, null);

        //让首结点指向新结点
        head.next = newNode;

        //让新结点指向原来的第一个结点
        newNode.next = oldFirst;

        //元素个数+1
        N++;

    }

    //弹出栈顶元素
    public T pop(){
        //找到首结点指向的第一个结点
        Node oldFirst = head.next;
        if (oldFirst == null){
            return null;
        }
        //让首结点指向原来第一个结点的下一个结点
        head.next = oldFirst.next;

        //元素个数-1
        N--;
        return oldFirst.item;
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator&lt;T&gt;{
        private Node n;

        public SIterator(){
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public T next() {
            Node node = n.next;
            n = n.next;
            return node.item;
        }


    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StackTest {
    public static void main(String[] args) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        //压栈
        stack.push("a");
        stack.push("b");
        stack.push("c");
        stack.push("d");

        for (String item : stack) {
            System.out.println(item);
        }
        System.out.println("=============================");

        //弹栈
        String pop = stack.pop();
        System.out.println("栈顶元素是：" +pop);
        System.out.println("当前栈的个数有："+ stack.size()+ "个");
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221001170056303.png" alt="image-20221001170056303"></p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><h6 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a><strong>括号匹配问题</strong></h6><p><strong>问题描述：</strong></p>
<p>给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。 </p>
<p>例如：</p>
<p>“(上海)(长安)”：正确匹配 </p>
<p>“上海((长安))”：正确匹配 </p>
<p>“上海(长安(北京)(深圳)南京)”:正确匹配 </p>
<p>“上海(长安))”：错误匹配 </p>
<p>“((上海)长安”：错误匹配 </p>
<p><strong>分析：</strong></p>
<p>1.创建一个栈用来存储左括号 </p>
<p>2.从左往右遍历字符串，拿到每一个字符 </p>
<p>3.判断该字符是不是左括号，如果是，放入栈中存储 </p>
<p>4.判断该字符是不是右括号，如果不是，继续下一次循环 </p>
<p>5.如果该字符是右括号，则从栈中弹出一个元素t； </p>
<p>6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号 </p>
<p>7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配</p>
<p><strong>代码实现</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BracketsMatchTest {
    public static void main(String[] args) {

        String str = "(上海(长安)))";
        boolean match = isMatch(str);
        System.out.println(str + "中的括号是否匹配？" + match);
    }

    public static boolean isMatch(String str){
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        //从左到右循环str字符串
        for (int i = 0; i &lt; str.length(); i++) {
            String s = str.charAt(i) + "";

            //判断当前的字符是否为左括号，如果是则放入栈中
            if (s.equals("(")){
                stack.push(s);
            }else if (s.equals(")")){
                //如果当前的字符为右括号，则从栈中弹出一个左括号，并判断弹出的结果是否为null，如果是null证明没有匹配的左括号
                String pop = stack.pop();
                if (pop == null){
                    return false;
                }
            }

        }

        //判断栈中还有没有剩余的左括号，如果有，则证明括号不匹配
        if (stack.size() == 0){
            return true;
        }else {
            return false;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221001172859268.png" alt="image-20221001172859268"></p>
<h6 id="逆波兰表达式求值问题"><a href="#逆波兰表达式求值问题" class="headerlink" title="逆波兰表达式求值问题"></a><strong>逆波兰表达式求值问题</strong></h6><p><strong>中缀表达式：</strong></p>
<p>中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。</p>
<p>中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。</p>
<p><strong>逆波兰表达式(后缀表达式)：</strong></p>
<p>逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。</p>
<table>
<thead>
<tr>
<th><strong>中缀表达式</strong></th>
<th><strong>逆波兰表达式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>a+b</td>
<td>ab+</td>
</tr>
<tr>
<td>a+(b-c)</td>
<td>abc-+</td>
</tr>
<tr>
<td>a+(b-c)*d</td>
<td>abc-d*+</td>
</tr>
<tr>
<td>a*(b-c)+d</td>
<td>abc-*d+</td>
</tr>
</tbody></table>
<p><strong>需求：</strong></p>
<p>给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。</p>
<p><strong>分析：</strong></p>
<p>1.创建一个栈对象stack存储操作数 </p>
<p>2.从左往右遍历逆波兰表达式，得到每一个字符串 </p>
<p>3.判断该字符串是不是运算符，如果不是，把该该操作数压入stack栈中 </p>
<p>4.如果是运算符，则从stack栈中弹出两个操作数o1，o2 </p>
<p>5.使用该运算符计算o1和o2，得到结果result </p>
<p>6.把该结果压入stack栈中 </p>
<p>7.遍历结束后，拿出栈中最终的结果返回 </p>
<p><strong>代码实现</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReversePolishNotation {
    public static void main(String[] args) {

        //中缀表达式3*（17-15）+18/6的逆波兰表达式如下
        String[] notation = {"3", "17", "15", "-", "*","18", "6","/","+"};
        int result = caculate(notation);
        System.out.println("逆波兰表达式的结果为："+result);
    }

    private static int caculate(String[] notation) {
        //1.创建一个栈对象oprands存储操作数
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        //2.从左往右遍历逆波兰表达式，得到每一个字符串
        for (int i = 0; i &lt; notation.length; i++) {
            String curr = notation[i];

            //3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中
            Integer o1;
            Integer o2;
            Integer result;
            switch (curr){
                case "+":
                    o1 = stack.pop();
                    o2 = stack.pop();
                    result = o2 + o1;
                    stack.push(result);
                    break;
                case "-":
                    o1 = stack.pop();
                    o2 = stack.pop();
                    result = o2 - o1;
                    stack.push(result);
                    break;
                case "*":
                    o1 = stack.pop();
                    o2 = stack.pop();
                    result = o2 * o1;
                    stack.push(result);
                    break;
                case "/":
                    o1 = stack.pop();
                    o2 = stack.pop();
                    result = o2 / o1;
                    stack.push(result);
                    break;

                default:
                    stack.push(Integer.parseInt(curr));
                    break;
            }
        }
        //7.遍历结束后，拿出栈中最终的结果返回
        Integer result = stack.pop();
        return result;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221001194552514.png" alt="image-20221001194552514"></p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种基于==<strong>先进先出(FIFO)</strong>==的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221001194718497.png" alt="image-20221001194718497"></p>
<h4 id="队列的API设计"><a href="#队列的API设计" class="headerlink" title="队列的API设计"></a>队列的API设计</h4><table>
<thead>
<tr>
<th>类</th>
<th><strong>Queue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Queue()：创建Queue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public boolean isEmpty()：判断队列是否为空，是返回true，否返回false                                                                                                                            2、public int size():  获取队列中元素的个数                                                                                                                                                                                           3、public T dequeue():  从队列中拿出一个元素                                                                                                                                                                                   4、public void enqueue(T t)：往队列中插入一个元素</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private Node head:  记录首结点                                                                                                                                                                                                        2、private int N:  当前栈的元素个数                                                                                                                                                                                                          3、private Node last:  记录最后一个结点</td>
</tr>
</tbody></table>
<h4 id="队列的代码实现"><a href="#队列的代码实现" class="headerlink" title="队列的代码实现"></a><strong>队列的代码实现</strong></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Queue&lt;T&gt; implements Iterable&lt;T&gt;{
    private Node head;//首结点
    private int N; //队列的元素个数
    private Node last; //队列的尾结点



    private class Node{
        public T item; //存储数据
        public Node next; //指向下一个结点
//        public Node last; //指向下一个结点

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }

    }

    public Queue(){
        this.head = new Node(null,null);
        this.N = 0;
        this.last =null;

    }

    //判断队列是否为空，是返回true，否返回false
    public boolean isEmpty(){
        return N == 0;
    }

    //获取队列中元素的个数
    public int size(){
        return N;
    }

    //  从队列中拿出一个元素
   public T dequeue() {
        //首先判断队列是否为null
        if (isEmpty()){
            return null;
        }
        Node oldFirst = head.next;
        head.next = oldFirst.next;

        //队列的元素个数-1
        N--;

       //因为出队列其实是在删除元素,因此如果队列中的元素被删除完了,需要重置last=null;
       if (isEmpty()){
           last = null;
       }

       return oldFirst.item;
   }

   //往队列中插入一个元素
    public void enqueue(T t){
        //当前尾结点last为null
        if (last == null){
            last = new Node(t, null);
            head.next = last;
        }else {
            //当前尾结点last不为null
            Node oldLast = last;
            last = new Node(t,null);
            oldLast.next = last;
        }


        //元素个数+1
        N++;


    }




    @Override
    public Iterator&lt;T&gt; iterator() {
        return new QIterator();
    }


    private class QIterator implements Iterator&lt;T&gt;{
        private Node n;
        public QIterator(){
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public T next() {
            Node node = n.next;
            n = n.next;
            return node.item;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>测试类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class QueueTest {
    public static void main(String[] args) {
        Queue&lt;String&gt; queue = new Queue&lt;&gt;();
        queue.enqueue("a");
        queue.enqueue("b");
        queue.enqueue("c");
        queue.enqueue("d");

        for (String s : queue) {
            System.out.println(s);
        }
        System.out.println("=================");
        queue.dequeue();


        for (String s : queue) {
            System.out.println(s);
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221001201913099.png" alt="image-20221001201913099"></p>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221001202707817.png" alt="image-20221001202707817"></p>
<p>符号表中，<strong>键具有唯一性</strong>。</p>
<p>符号表在实际生活中的使用场景是非常广泛的，见下表：</p>
<table>
<thead>
<tr>
<th><strong>应用</strong></th>
<th><strong>查找目的</strong></th>
<th><strong>键</strong></th>
<th><strong>值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>字典</td>
<td>找出单词的释义</td>
<td>单词</td>
<td>释义</td>
</tr>
<tr>
<td>图书索引</td>
<td>找出某个术语相关的页码</td>
<td>术语</td>
<td>一串页码</td>
</tr>
<tr>
<td>网络搜索</td>
<td>找出某个关键字对应的网页</td>
<td>关键字</td>
<td>网页名称</td>
</tr>
</tbody></table>
<h3 id="符号表API设计"><a href="#符号表API设计" class="headerlink" title="符号表API设计"></a>符号表API设计</h3><p><strong>结点类：</strong></p>
<table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key,Value value,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、public Key key: 存储键                                                                                                                                                                                                                                    2、public Value value:  存储值                                                                                                                                                                                                                        3、public Node next:  存储下一个结点</td>
</tr>
</tbody></table>
<p><strong>符号表：</strong></p>
<table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>SymbolTable&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SymbolTable()：创建SymbolTable对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、public Value get(Key key)：根据键key，找对应的值                                                                                                                                                                                       2、public void put(Key key,Value val):  向符号表中插入一个键值对                                                                                                                                                      3、public void delete(Key key):  删除键为key的键值对                                                                                                                                                                                    4、public int size()：获取符号表的大小</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private Node head:记录首结点                                                                                                                                                                                                                                                                          2、private int N:记录符号表中键值对的个数</td>
</tr>
</tbody></table>
<h3 id="符号表的代码实现"><a href="#符号表的代码实现" class="headerlink" title="符号表的代码实现"></a><strong>符号表的代码实现</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SymbolTable &lt;Key,Value&gt;{
    //首结点
    private Node head;

    //记录符号表中的元素个数
    private int N;


    private class Node{
        //键
        private Key key;
        //值
        private Value value;

        //下一个结点
        private Node next;

        public Node(Key key,Value value,Node next){
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public SymbolTable(){
        this.head = new Node(null,null,null);
        this.N = 0;
    }


    //根据键key，找对应的值
    public Value get(Key key) {
        //找到键为key的键值对结点
        Node n = head;
        while (n.next != null){
            //变换n
            n = n.next;
            if (n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }

    //向符号表中插入一个键值对
    public void put(Key key,Value value){
        //符号表中已经存在了键key的键值对，那么只要找到该结点，替换值为value即可
        Node n = head;
        while (n.next != null){
            //变换n
            n = n.next;
            //判断n结点存储的键是否为key，如果是，则替换n结点的value值
            if (n.key.equals(key)){
                n.value = value;
                return;
            }
        }

        //如果符号表中不存在键为key的键值对，只需创建新的结点，保存要插入的键值对，把新结点插入到链表的头部，head.next = 新的结点即可
        Node newNode = new Node(key, value, null);
        Node oldFirst = head.next;
        newNode.next = oldFirst;
        head.next = newNode;


        //元素个数+
        N++;

    }


    // 删除键为key的键值对
    public void delete(Key key){
        //找到键为key的键值对结点，把结点从链表中删除
        Node n = head;
        while (n.next != null){
            //判断n结点的下一结点的键是否为key，如果是，则删除该结点
            if (n.next.key.equals(key)){
                n.next = n.next.next;
                N--;
                return;
            }

            //变换n
            n = n.next;

        }

    }

    //获取符号表的大小
    public int size(){
        return N;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SymbolTableTest {
    public static void main(String[] args) {
        SymbolTable&lt;Integer, String &gt; symbolTable = new SymbolTable&lt;&gt;();

        symbolTable.put(1,"乔峰");
        symbolTable.put(2,"虚竹");
        symbolTable.put(3,"段誉");
        symbolTable.put(1,"郭靖");

        System.out.println("插入完毕后，元素的个数为："+ symbolTable.size());

        System.out.println(symbolTable.get(1));


    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221001235607219.png" alt="image-20221001235607219"></p>
<h3 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a><strong>有序符号表</strong></h3><p>刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，那么接下来我们就实现一下有序符号表。</p>
<h4 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class OrderSymbolTable &lt;Key extends Comparable&lt;Key&gt;, Value&gt; implements Iterable{
    //首结点
    private Node head;

    //记录符号表中的元素个数
    private int N;

    private class Node{
        //键
        private Key key;
        //值
        private Value value;

        //下一个结点
        private Node next;

        public Node(Key key,Value value,Node next){
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public OrderSymbolTable(){
        this.head = new Node(null,null,null);
        this.N = 0;
    }


    //根据键key，找对应的值
    public Value get(Key key) {
        //找到键为key的键值对结点
        Node n = head;
        while (n.next != null){
            //变换n
            n = n.next;
            if (n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }

    //向符号表中插入一个键值对
    public void put(Key key,Value value){
        //定义两个Node变量，分别记录当前结点和当前结点的上一个结点
           Node curr = head.next;
           Node pre = head;
           while (curr != null &amp;&amp; key.compareTo(curr.key) &gt; 0){
              //变换当前结点和前一个结点即可
               pre = curr;
               curr = curr.next;
           }

           //如果当前结点curr的键和要插入的key一样,则替换
            if (curr != null &amp;&amp; key.compareTo(curr.key) == 0){
               curr.value = value;
               return;
           }

            //如果当前结点curr的键和要插入的key不一样﹐把新的结点插入到curr之前
            Node node = new Node(key, value, curr);
            pre.next = node;

           //元素个数+1
            N++;


    }


    // 删除键为key的键值对
    public void delete(Key key){
        //找到键为key的键值对结点，把结点从链表中删除
        Node n = head;
        while (n.next != null){
            //判断n结点的下一结点的键是否为key，如果是，则删除该结点
            if (n.next.key.equals(key)){
                n.next = n.next.next;
                N--;
                return;
            }

            //变换n
            n = n.next;

        }

    }

    //获取符号表的大小
    public int size(){
        return N;
    }

    @Override
    public Iterator iterator() {
        return new SIterator();
    }


    private class SIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        private Node n;

        public SIterator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public T next() {
            Node node = n.next;
            n = n.next;
            return (T) get(node.key);

        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class OrderSymbolTableTest {
    public static void main(String[] args) {
        OrderSymbolTable&lt;Integer, String&gt; symbolTable = new OrderSymbolTable&lt;&gt;();
        symbolTable.put(1,"张三");
        symbolTable.put(2,"李四");
        symbolTable.put(7,"王五");
        symbolTable.put(4,"赵六");
        symbolTable.put(3,"田七");

        for (Object o : symbolTable) {
            System.out.println(o);
        }

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221002002149449.png" alt="image-20221002002149449"></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树入门"><a href="#二叉树入门" class="headerlink" title="二叉树入门"></a><strong>二叉树入门</strong></h3><p>在符号表中，不难看出，符号表的增删查操作，随着元素个数N的增多，其耗时也是线性增多的，时间复杂度都是O(n),为了提高运算效率，接下来我们学习树这种数据结构。</p>
<h4 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a><strong>树的基本定义</strong></h4><p>树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。</p>
<p>树是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221002123247065.png" alt="image-20221002123247065"></p>
<p>树具有以下特点：</p>
<p> 1.每个结点有零个或多个子结点；</p>
<p> 2.没有父结点的结点为根结点；</p>
<p> 3.每一个非根结点只有一个父结点；</p>
<p> 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</p>
<h4 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a><strong>树的相关术语</strong></h4><p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度；</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点称为叶结点，也可以叫做终端结点</p>
<p><strong>分支结点：</strong></p>
<p>度不为0的结点称为分支结点，也可以叫做非终端结点</p>
<p><strong>结点的层次：</strong></p>
<p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推</p>
<p><strong>结点的层序编号：</strong></p>
<p>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值</p>
<p><strong>树的高度(深度)：</strong></p>
<p>树中结点的最大层次</p>
<p><strong>森林：</strong></p>
<p> m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根</p>
<p>结点，森林就变成一棵树</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221002124044681.png" alt="image-20221002124044681"></p>
<p><strong>孩子结点：</strong></p>
<p>一个结点的直接后继结点称为该结点的孩子结点</p>
<p><strong>双亲结点(父结点)：</strong></p>
<p>一个结点的直接前驱称为该结点的双亲结点</p>
<p><strong>兄弟结点：</strong></p>
<p>同一双亲结点的孩子结点间互称兄弟结点</p>
<h3 id="二叉树的基本定义"><a href="#二叉树的基本定义" class="headerlink" title="二叉树的基本定义"></a><strong>二叉树的基本定义</strong></h3><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221002124224073.png" alt="image-20221002124224073"></p>
<p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。每一层的结点数为：2^(k-1)个</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221002124240262.png" alt="image-20221002124240262"></p>
<p><strong>完全二叉树：</strong></p>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221002124527705.png" alt="image-20221002124527705"></p>
<h3 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a><strong>二叉查找树的创建</strong></h3><h4 id="二叉树的结点类"><a href="#二叉树的结点类" class="headerlink" title="二叉树的结点类"></a><strong>二叉树的结点类</strong></h4><p>根据对树的观察，我们发现二叉树其实就是由一个一个的结点及其之间的关系组成的，按照面向对象的思想，我们设计一个结点类来描述结点这个事物。</p>
<h4 id="结点类API设计："><a href="#结点类API设计：" class="headerlink" title="结点类API设计："></a><strong>结点类API设计：</strong></h4><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node left, Node right)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、public Node left:记录左子结点 <br>2、public Node right:记录右子结点  <br>3、public Key key:存储键  <br>4、public Value value:存储值</td>
</tr>
</tbody></table>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a><strong>代码实现：</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Node &lt;Key,Value&gt;{

    public Node left; //记录左子结点
    public Node right; //记录右子结点
    public Key key; //存储键
    public Value value; //存储值

    public Node(Node left, Node right, Key key, Value value) {
        this.left = left;
        this.right = right;
        this.key = key;
        this.value = value;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="二叉查找树API设计"><a href="#二叉查找树API设计" class="headerlink" title="二叉查找树API设计"></a><strong>二叉查找树API设计</strong></h4><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>BinaryTree&lt;Key，value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BinaryTree()：创建BinaryTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private Node root:记录根结点 <br>2、private int N:记录树中元素的个数</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、 public void put(Key key,Value value):向树中插入一个键值对<br>2、private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3、public Value get(Key key):根据key，从树中找出对应的值<br> 4、private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br> 5、public void delete(Key key):根据key，删除树中对应的键值对<br>6、private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7、public int size():获取树中元素的个数</td>
</tr>
</tbody></table>
<h4 id="二叉查找树实现"><a href="#二叉查找树实现" class="headerlink" title="二叉查找树实现"></a><strong>二叉查找树实现</strong></h4><p><strong>插入方法put实现思想：</strong></p>
<p>1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</p>
<p>2.如果当前树不为空，则从根结点开始：</p>
<p> 2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003163343438.png" alt="image-20221003163343438"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003163749805.png" alt="image-20221003163749805"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003163914699.png" alt="image-20221003163914699"></p>
<p><strong>查询方法get实现思想：</strong></p>
<p>从根节点开始：</p>
<p>1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<p><strong>删除方法delete实现思想：</strong></p>
<p> 1.找到被删除结点；</p>
<p> 2.找到被删除结点右子树中的最小结点minNode</p>
<p> 3.删除右子树中的最小结点</p>
<p> 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树</p>
<p> 5.让被删除结点的父节点指向最小结点minNode</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003204636296.png" alt="image-20221003204636296"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003205056842.png" alt="image-20221003205056842"></p>
<h5 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BinaryTree &lt;Key extends Comparable&lt;Key&gt;,Value &gt;{

    private Node root;//记录根结点

     private int N; //记录树中元素的个数

    public BinaryTree(){

    }

    //向树中插入一个键值对
    public void put(Key key,Value value){
        root = put(root,key,value);

    }

    //给指定树x上，添加键一个键值对，并返回添加后的新树
    private Node put(Node x, Key key, Value value){
        //如果x子树为空
        if (x == null){
            N++; //元素个数+1
            return new Node(key,value,null,null);
        }

        //如果x子树不为空
        int i = key.compareTo((Key) x.key);
        if (i &gt; 0){ //比较x结点的键key的大小
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right = put(x.right,key,value);
        }else if (i &lt; 0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = put(x.left,key,value);
        }else {
            //如果key等于x结点的键，则替换x结点的值value即可
            x.value = value;
        }

        return x;
    }

    //根据key，从树中找出对应的值
    public Value get(Key key){
        return get(root,key);
    }

    //从指定的树x中，找出key对应的值
    private Value get(Node x, Key key){
        //如果x树为null
        if (x == null){
            return null;
        }

        //如果x树不为null
        int i = key.compareTo((Key) x.key);
        if (i &gt; 0){ //比较x结点的键key的大小
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.right,key);
        }else if (i &lt; 0){
            //如果key小于x结点的键，则继续找x结点的左子树
            return get(x.left,key);
        }else {
            //如果key等于x结点的键，则直接返回x结点的值value即可
            return (Value) x.value;
        }

    }

    //根据key，删除树中对应的键值对
    public void delete(Key key){
        delete(root,key);
    }

    //删除指定树x上的键为key的键值对，并返回删除后的新树
    private Node delete(Node x, Key key){
        //如果x树为null
        if (x == null){
            return null;
        }

        //如果x树不为null
        int i = key.compareTo((Key) x.key);
        if (i &gt; 0){ //比较x结点的键key的大小
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right =  delete(x.right,key);
        }else if (i &lt; 0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = delete(x.left,key);
        }else {
            //元素个数-1
            N--;
            //如果key等于x结点的键，则直接删除x结点即可

            //找到要删除的结点的右子树中最小的结点
            if (x.right == null){
                return x.left;
            }
            //找到要删除的结点的右子树中没有左结点
            if (x.left == null){
                return x.right;
            }
            Node minNode = x.right;
            while (minNode != null){
                minNode = minNode.left;
            }

            //删除右子树中最小的结点
            Node n = x.right;
            while (n.left != null){
                if (n.left.left == null){
                    n.left = null;
                }else {
                    //变换n结点
                    n = n.left;
                }
            }
            //让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            //让x结点的父结点指向minNode
            x = minNode;

        }
        return x;
    }

   // 获取树中元素的个数
    public int size(){
        return N;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BinaryTreeTest {
    public static void main(String[] args) {
        BinaryTree&lt;Integer, String &gt; tree = new BinaryTree&lt;&gt;();

        //插入数据
        tree.put(4,"张三");
        tree.put(2,"李四");
        tree.put(3,"王五");
        tree.put(1,"赵六");
        System.out.println("插入完毕后元素的个数为：" + tree.size());

        //获取指定key的value
        System.out.println("获取key为2的value为："+ tree.get(2));

        //删除指定key的value
        tree.delete(3);
        System.out.println("删除key为3的元素后，树中元素的个数为："+tree.size());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003211751647.png" alt="image-20221003211751647"></p>
<h4 id="查找二叉树中最小的键"><a href="#查找二叉树中最小的键" class="headerlink" title="查找二叉树中最小的键"></a><strong>查找二叉树中最小的键</strong></h4><table>
<thead>
<tr>
<th><strong>public Key min()</strong></th>
<th><strong>找出树中最小的键</strong></th>
</tr>
</thead>
<tbody><tr>
<td>private Node min(Node x)</td>
<td>找出指定树x中，最小键所在的结点</td>
</tr>
</tbody></table>
<h5 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h5><p>在 BinaryTree类的基础上添加如下代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//找出树中最小的键
public Key min(){
    return (Key) min(root).key;
}

//找出指定树x中，最小键所在的结点
private Node min(Node x){
    //需要判断x还有没左子树，如果有，则继续向左查找，如果没有，则x就是最小的键所在的结点
    if (x.left != null){
        return min(x.left);
    }else {
        return x;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="查找二叉树中最大的键"><a href="#查找二叉树中最大的键" class="headerlink" title="查找二叉树中最大的键"></a><strong>查找二叉树中最大的键</strong></h4><table>
<thead>
<tr>
<th><strong>public Key max()</strong></th>
<th><strong>找出树中最大的键</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public Node max(Node x)</td>
<td>找出指定树x中，最大键所在的结点</td>
</tr>
</tbody></table>
<h5 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h5><p>在 BinaryTree类的基础上添加如下代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//找出树中最大的键
    public Key max(){
        return (Key) max(root).key;
    }

    //找出指定树x中，最大键所在的结点
    public Node max(Node x){
        //需要判断x还有没右子树，如果有，则继续向右查找，如果没有，则x就是最大的键所在的结点
        if (x.right != null){
            return max(x.right);
        }else {
            return x;
        }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003214600239.png" alt="image-20221003214600239"></p>
<h3 id="二叉树的基础遍历"><a href="#二叉树的基础遍历" class="headerlink" title="二叉树的基础遍历"></a><strong>二叉树的基础遍历</strong></h3><p>很多情况下，我们可能需要像遍历数组数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的<strong>搜索路径</strong>进行遍历的问题。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003214537685.png" alt="image-20221003214537685"></p>
<p>我们把树简单的画作上图中的样子，由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把二叉树的遍历分为以下三种方式：</p>
<p> 1.前序遍历：</p>
<p>先访问根结点，然后再访问左子树，最后访问右子树</p>
<p> 2.中序遍历：</p>
<p>先访问左子树，中间访问根节点，最后访问右子树</p>
<p> 3.后序遍历：</p>
<p>先访问左子树，再访问右子树，最后访问根节点</p>
<p>==<strong>这三种方式利用了深度优先的遍历思想</strong>==</p>
<p>如果我们分别对下面的树使用三种遍历方式进行遍历，得到的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003214834680.png" alt="image-20221003214834680"></p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><strong>前序遍历</strong></h4><p>我们在BinaryTree类上，添加前序遍历的API： </p>
<p><code>public Queue&lt;Key&gt; preErgodic()</code>：使用前序遍历，获取整个树中的所有键 </p>
<p><code>private void preErgodic(Node x,Queue&lt;Key&gt; keys)</code>：使用前序遍历，把指定树x中的所有键放入到keys队列中</p>
<p>实现过程中，我们通过前序遍历，把,把每个结点的键取出，放入到队列中返回即可。</p>
<p><strong>实现步骤：</strong></p>
<p>1.把当前结点的key放入到队列中;</p>
<p>2.找到当前结点的左子树，如果不为空，递归遍历左子树</p>
<p>3.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
<p><strong>代码：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用前序遍历，获取整个树中的所有键
public Queue&lt;Key&gt; preErgodic(){
    Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
    preErgodic(root,keys);
    return keys;
}

//使用前序遍历，把指定树x中的所有键放入到keys队列中
private void preErgodic(Node x, Queue&lt;Key&gt; keys){
    if (x == null){
        return;
    }
    //把x结点的key放到keys中
    keys.enqueue((Key) x.key);

    //递归遍历x结点的左子树
    if (x.left != null){
        preErgodic(x.left,keys);
    }

    //递归遍历x的右子树
    if (x.right != null){
        preErgodic(x.right,keys);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003231733571.png" alt="image-20221003231733571"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><strong>中序遍历</strong></h4><p>我们在BinaryTree类上，添加前序遍历的API： </p>
<p><code>public Queue&lt;Key&gt; midErgodic()</code>：使用中序遍历，获取整个树中的所有键 </p>
<p><code>private void midErgodic(Node x,Queue&lt;Key&gt; keys)</code>：使用中序遍历，把指定树x中的所有键放入到keys队列中</p>
<p><strong>实现步骤：</strong></p>
<p>1.找到当前结点的左子树，如果不为空，递归遍历左子树</p>
<p>2.把当前结点的key放入到队列中;</p>
<p>3.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
<p><strong>代码：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用中序遍历，获取整个树中的所有键
public Queue&lt;Key&gt; midErgodic(){
    Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
    midErgodic(root,keys);
    return keys;
}

//使用中序遍历，把指定树x中的所有键放入到keys队列中
private void midErgodic(Node x,Queue&lt;Key&gt; keys){
    if (x == null){
        return;
    }
    //先递归，把左子树中的键放到keys中
    if (x.left != null){
        midErgodic(x.left,keys);
    }

    //把当前结点的键放到keys中
    keys.enqueue((Key) x.key);

    //在递归，把右子树中的键放到keys中
    if (x.right != null){
        midErgodic(x.right,keys);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><strong>后序遍历</strong></h4><p>我们在BinaryTree类上，添加前序遍历的API： </p>
<p><code>public Queue&lt;Key&gt; afterErgodic()</code>：使用后序遍历，获取整个树中的所有键 </p>
<p><code>private void afterErgodic(Node x,Queue&lt;Key&gt; keys)</code>：使用后序遍历，把指定树x中的所有键放入到keys队列中</p>
<p><strong>实现步骤：</strong></p>
<p>1.找到当前结点的左子树，如果不为空，递归遍历左子树</p>
<p>2.找到当前结点的右子树，如果不为空，递归遍历右子树</p>
<p>3.把当前结点的key放入到队列中; </p>
<p><strong>代码：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用后序遍历，获取整个树中的所有键
public Queue&lt;Key&gt; afterErgodic(){
    Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
    afterErgodic(root,keys);
    return keys;

}

//使用后序遍历，把指定树x中的所有键放入到keys队列中
private void afterErgodic(Node x,Queue&lt;Key&gt; keys){
    if (x == null){
        return;
    }

    //先递归，把左子树中的键放到keys中
    if (x.left != null){
        afterErgodic(x.left,keys);
    }

    //在递归，把右子树中的键放到keys中
    if (x.right != null){
        afterErgodic(x.right,keys);
    }

    //把当前结点的键放到keys中
    keys.enqueue((Key) x.key);

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package cn.example.algorithm.test.tree;

import cn.example.algorithm.linearTable.Queue;
import cn.example.algorithm.tree.BinaryTree;

public class BinaryTreeErgodicTest {
    public static void main(String[] args) {
        BinaryTree&lt;String, String &gt; tree = new BinaryTree&lt;&gt;();

        //插入数据
        tree.put("E","5");
        tree.put("B","2");
        tree.put("G","7");
        tree.put("A","1");
        tree.put("D","4");
        tree.put("F","6");
        tree.put("H","8");
        tree.put("C","3");

        Queue&lt;String&gt; queue = tree.preErgodic();
        System.out.println("前序遍历为：");
        for (String key : queue) {
            System.out.print(key);
        }

        System.out.println();
        System.out.println("=====================");

        Queue&lt;String&gt; queue1 = tree.midErgodic();
        System.out.println("中序遍历为：");
        for (String key : queue1) {
            System.out.print(key);
        }


        System.out.println();
        System.out.println("=====================");

        Queue&lt;String&gt; queue3 = tree.afterErgodic();
        System.out.println("后序遍历为：");
        for (String key : queue3) {
            System.out.print(key);
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003234217508.png" alt="image-20221003234217508"></p>
<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><strong>二叉树的层序遍历</strong></h3><p>==<strong>层序遍历利用到广度优先的遍历思想</strong>==</p>
<p>所谓的层序遍历，就是从根节点（第一层）开始，依次向下（从上往下，从左往右），获取每一层所有结点的值，有二叉树如下：</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003234248905.png" alt="image-20221003234248905"></p>
<p>那么层序遍历的结果是：EBGADFHC</p>
<p>我们在BinaryTree类上，添加层序遍历的API： </p>
<p>public Queue<key> layerErgodic()：使用层序遍历，获取整个树中的所有键</key></p>
<p><strong>实现步骤：</strong></p>
<p>1.创建队列，存储每一层的结点；</p>
<p>2.使用循环从队列中弹出一个结点：</p>
<p> 2.1获取当前结点的key；</p>
<p> 2.2如果当前结点的左子结点不为空，则把左子结点放入到队列中</p>
<p> 2.3如果当前结点的右子结点不为空，则把右子结点放入到队列中</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003234600220.png" alt="image-20221003234600220"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221003234803408.png" alt="image-20221003234803408"></p>
<p><strong>代码：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用层序遍历，获取整个树中的所有键
public Queue&lt;Key&gt; layerErgodic(){
    //定义两个队列，分别存储树的键和树中的结点
    Queue&lt;Key&gt; keys = new Queue&lt;&gt;();
    Queue&lt;Node&gt; nodes = new Queue&lt;&gt;();

    //默认往队列中存放根结点
    nodes.enqueue(root);

    while (!nodes.isEmpty()){
        //从队列中弹出一个结点，把key放入到keys中
        Node n = nodes.dequeue();
        keys.enqueue((Key) n.key);

        //判断当前的结点还有没有左子结点，如果右，则放到nodes中
        if (n.left != null){
            nodes.enqueue(n.left);
        }

        //判断当前的结点还有没有右子结点，如果右，则放到nodes中
        if (n.right != null){
            nodes.enqueue(n.right);
        }
    }
    return keys;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a><strong>二叉树的最大深度问题</strong></h3><p><strong>需求：</strong></p>
<p>给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）;</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004000523511.png" alt="image-20221004000523511"></p>
<p>上面这棵树的最大深度为4。</p>
<p><strong>实现：</strong></p>
<p>我们在BinaryTree类上，添加如下的API求最大深度：</p>
<p><code>public int maxDepth()</code>：计算整个树的最大深度 </p>
<p><code>private int maxDepth(Node x)</code>:  计算指定树x的最大深度 </p>
<p><strong>实现步骤：</strong></p>
<p>1.如果根结点为空，则最大深度为0；</p>
<p>2.计算左子树的最大深度；</p>
<p>3.计算右子树的最大深度；</p>
<p>4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</p>
<p><strong>代码：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">//计算整个树的最大深度
public int maxDepth(){
    return maxDepth(root);
}

//计算指定树x的最大深度
private int maxDepth(Node x){
    if (x == null){
        return 0;
    }
    int max = 0;//x的最大深度
    int maxL = 0;//左子树的最大深度
    int maxR = 0;//右子树的最大深度

    //计算x结点左子树的最大深度
    if (x.left != null){
        maxL = maxDepth(x.left);
    }

    //计算x结点右子树的最大深度
    if (x.right != null){
        maxR = maxDepth(x.right);
    }

    //比较左子树最大深度与右子树最大深度，取较大值+1即可
    max = maxL &gt; maxR? maxL +1 : maxR + 1;
    return max;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a><strong>折纸问题</strong></h3><p><strong>需求：</strong></p>
<p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p>
<p>给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 </p>
<p>例如：N=1时，打印： down；N=2时，打印： down down up</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004001748329.png" alt="image-20221004001748329"></p>
<p><strong>分析：</strong></p>
<p>我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。</p>
<p>这棵树有这样的特点：</p>
<p>1.根结点为下折痕；</p>
<p>2.每一个结点的左子结点为下折痕；</p>
<p>3.每一个结点的右子结点为上折痕；</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004002322517.png" alt="image-20221004002322517"></p>
<p><strong>实现步骤：</strong></p>
<p> 1.定义结点类</p>
<p> 2.构建深度为N的折痕树；</p>
<p> 3.使用中序遍历，打印出树中所有结点的内容；</p>
<p><strong>构建深度为N的折痕树：</strong></p>
<p>1.第一次对折，只有一条折痕，创建根结点；</p>
<p>2.如果不是第一次对折，则使用队列保存根结点；</p>
<p>3.循环遍历队列：</p>
<p> 3.1从队列中拿出一个结点；</p>
<p> 3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；</p>
<p> 3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；</p>
<p> 3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</p>
<p><strong>代码：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PaperFoldingTest {
    public static void main(String[] args) {
        //构建折痕树
        Node tree = createTree(3);

        //遍历折痕树，并打印
        printTree(tree);
    }

    //3.使用中序遍历，打印出树中所有结点的内容
    private static void printTree(Node tree) {
        if (tree==null){
            return;
        }

        printTree(tree.left);
        System.out.print(tree.item+",");
        printTree(tree.right);
    }


    //2.构建深度为N的折痕树
    private static Node createTree(int N) {
        Node root = null;
        for (int i = 0; i &lt; N; i++) {
            if (i == 0) {
                //1.第一次对折，只有一条折痕，创建根结点
                root = new Node("down", null, null);
                continue;
            } else {
                //2.如果不是第一次对折，则使用队列保存根结点
                Queue&lt;Node&gt; queue = new Queue&lt;&gt;();
                queue.enqueue(root);

                //3.循环遍历队列：
                while (!queue.isEmpty()) {
                    //3.1从队列中拿出一个结点；
                    Node tmp = queue.dequeue();

                    //3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中
                    if (tmp.left != null) {
                        queue.enqueue(tmp.left);
                    }
                    //3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中
                    if (tmp.right != null) {
                        queue.enqueue(tmp.right);
                    }
                    //3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个 值为down的左子结点，一个值为up的右子结点
                    if (tmp.left == null &amp;&amp; tmp.right == null) {
                        tmp.left = new Node("down", null, null);
                        tmp.right = new Node("up", null, null);
                    }
                }
            }
        }
        return root;

    }



    //1.定义结点类
    private static class Node{
        //存储结点元素
        String item;

        //左子结点
        Node left;

        //右子结点
        Node right;

        public Node(String item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a><strong>堆的定义</strong></h3><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p>
<h3 id="堆的特性"><a href="#堆的特性" class="headerlink" title="堆的特性"></a><strong>堆的特性</strong></h3><p> 1、它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004141352957.png" alt="image-20221004141352957"></p>
<p> 2、它通常用数组来实现。具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004141733396.png" alt="image-20221004141733396"></p>
<p>如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2,向下一层就令k等于2k或2k+1。</p>
<p> 3、每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</p>
<h3 id="堆的API设计"><a href="#堆的API设计" class="headerlink" title="堆的API设计"></a><strong>堆的API设计</strong></h3><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th>Heap&lt;T extends Comparable<t>&gt;</t></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Heap(int capacity)：创建容量为capacity的Heap对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1、private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2、private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3、public T delMax():删除堆中最大的元素,并返回这个最大元素<br>4、public void insert(T t)：往堆中插入一个元素<br>5、private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6、private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</td>
</tr>
<tr>
<td>成员变量</td>
<td>1、private T[] imtes : 用来存储元素的数组<br>2、private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a><strong>堆的实现</strong></h3><h4 id="insert插入方法的实现"><a href="#insert插入方法的实现" class="headerlink" title="insert插入方法的实现"></a><strong>insert插入方法的实现</strong></h4><p>堆是用数组完成数据元素的存储的，由于数组的底层是一串连续的内存地址，所以我们要往堆中插入数据，我们只能往数组中从索引0处开始，依次往后存放数据，但是堆中对元素的顺序是有要求的，每一个结点的数据要大于等于它的两个子结点的数据，所以每次插入一个元素，都会使得堆中的数据顺序变乱，这个时候我们就需要通过一些方法让刚才插入的这个数据放入到合适的位置。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004234631876.png" alt="image-20221004234631876"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004234708965.png" alt="image-20221004234708965"></p>
<p><img src="D:\java笔记\笔记\数据结构与算法.assets\image-20221004234842176.png" alt="image-20221004234842176"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004234926765.png" alt="image-20221004234926765"></p>
<p>所以，如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整。</p>
<h4 id="delMax删除最大元素方法的实现"><a href="#delMax删除最大元素方法的实现" class="headerlink" title="delMax删除最大元素方法的实现"></a>delMax删除最大元素方法的实现</h4><p>由堆的特性我们可以知道，索引1处的元素，也就是根结点就是最大的元素，当我们把根结点的元素删除后，需要有一个新的根结点出现，这时我们可以暂时把堆中最后一个元素放到索引1处，充当根结点，但是它有可能不满足堆的有序性需求，这个时候我们就需要通过一些方法，让这个新的根结点放入到合适的位置</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004235124581.png" alt="image-20221004235124581"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004235157230.png" alt="image-20221004235157230"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004235218213.png" alt="image-20221004235218213"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004235250180.png" alt="image-20221004235250180"></p>
<p><img src="/../../../java%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20221004235324483.png" alt="image-20221004235324483"></p>
<p>所以，当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k]和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。</p>
<h3 id="堆的代码实现"><a href="#堆的代码实现" class="headerlink" title="堆的代码实现"></a><strong>堆的代码实现</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Heap&lt;T extends Comparable&lt;T&gt;&gt; {
    private T[] items; // 用来存储元素的数组
    private int N;  //记录堆中元素的个数

    public Heap(int capacity){
        this.items = (T[]) new Comparable[capacity];
        this.N = 0;
    }


    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j]) &lt; 0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i,int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    //删除堆中最大的元素,并返回这个最大元素
    public T delMax(){
        T max = items[1];

        //交换索引1出的元素和最大索引出的元素，让完全二叉树中最右侧的元素变为临时结结点
        exch(1,N);

        //删除最大索引处的元素
        items[N] = null;

        //元素个数-1
        N--;

        //通过下沉调整堆，让堆重新有序
        sink(1);
        return max;

    }

    //往堆中插入一个元素
    public void insert(T t){
        items[++N] = t;
        swim(N);
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){
        //通过循环，不断的比较当前结点的值和其父结点的值，如果发现父结点的值比当前结点的值小，则交换位置
        while (k &gt; 1){
            //比较当前结点和其父结点
            if (less(k/2,k)){
                exch(k/2,k);
            }
            k = k/2;
        }
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k){
        //通过循环不断的对比当前k结点和其左子结点2k+1处的较大值的元素大小，如果当前结点小，则需要交换位置
        while (2*k &lt;= N){
            //获取当前结点的子结点中较大的结点
            int max; //记录较大结点所在的索引
            if (2*k+1 &lt; N){
                if (less(2*k,2*k+1)){
                    max = 2*k+1;
                }else {
                    max = 2*k;
                }
            }else {
                max = 2*k;
            }

            //比较当前结点和较大结点的值
            if (!less(k,max)){
                break;
            }

            //交换k索引出的值和max索引处的值
            exch(k,max);

            //变换k的值
            k = max;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HeapTest {
    public static void main(String[] args) {
        Heap&lt;String &gt; heap = new Heap&lt;&gt;(10);
        heap.insert("A");
        heap.insert("B");
        heap.insert("C");
        heap.insert("D");
        heap.insert("E");
        heap.insert("F");
        heap.insert("G");

        //删除堆中的数据
        String result = null;
        while ((result = heap.delMax()) !=null){
            System.out.print(result + "\t");
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221004234526777.png" alt="image-20221004234526777"></h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h3><p>给定一个数组：</p>
<p> String[] arr = {“S”,”O”,”R”,”T”,”E”,”X”,”A”,”M”,”P”,”L”,”E”}</p>
<p>请对数组中的字符按从小到大排序。</p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>构造堆</li>
<li>得到堆顶元素，这个值就是最大值</li>
<li>交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置</li>
<li>对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶</li>
<li>重复2~4这个步骤，直到堆中剩一个元素为止。</li>
</ul>
<h4 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h4><table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th>**HeapSort&lt;T extends Comparable<t>&gt; **</t></th>
</tr>
</thead>
<tbody><tr>
<td>成员方法</td>
<td>1、public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br>2、private static void createHeap(Comparable[] source, Comparable[] heap):  根据原数组source，构造出堆heap<br>3、private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素<br>4、private static void exch(Comparable[] heap, int i, int j):  交换heap堆中i索引和j索引处的值<br>5、private static void sink(Comparable[] heap, int target, int range):  在heap堆中，对target处的元素做下沉，范围是0~range。</td>
</tr>
</tbody></table>
<h4 id="堆构造过程"><a href="#堆构造过程" class="headerlink" title="堆构造过程"></a><strong>堆构造过程</strong></h4><p>堆的构造，最直观的想法就是另外再创建一个和新数组数组，然后从左往右遍历原数组，每得到一个元素后，添加到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。</p>
<p>上述的方式虽然很直观，也很简单，但是我们可以用更聪明一点的办法完成它。创建一个新数组，把原数组0~ length-1的数据拷贝到新数组的1~length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后对扫描到的每一个元素做下沉调整即可。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221005000200768.png" alt="image-20221005000200768"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221005000422579.png" alt="image-20221005000422579"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221005000451196.png" alt="image-20221005000451196"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221005000609642.png" alt="image-20221005000609642"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221005000642537.png" alt="image-20221005000642537"></p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221005000718891.png" alt="image-20221005000718891"></p>
<h4 id="堆排序过程"><a href="#堆排序过程" class="headerlink" title="堆排序过程"></a><strong>堆排序过程</strong></h4><p>对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。</p>
<p>1.将堆顶元素和堆中最后一个元素交换位置；</p>
<p>2.通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边)</p>
<p>3.重复1~2步骤，直到堆中剩最后一个元素。</p>
<h4 id="代码实现-16"><a href="#代码实现-16" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; {

    //对source数组中的数据从小到大排序
    public static void sort(Comparable[] source){
        //构建堆
        Comparable[] heap = new Comparable[source.length+1];
        createHeap(source,heap);

        //定义一个变量，记录未排序的元素中最大的索引
        int N = heap.length-1;

        //通过循环，交换1索引出的元素和排序的元素中最大的随意处的元素
        while (N != 1){
            //交换元素
            exch(heap,1,N);

            //排序交换后的最大元素所在的索引，让它不需要参与下沉调整
            N--;

            //需要对索引1处的元素进行堆的下沉调整
            sink(heap,1,N);
        }

        //把heap中的数据拷贝到原数组source中
        System.arraycopy(heap,1,source,0,source.length);

    }

    //根据原数组source，构造出堆heap
    private static void createHeap(Comparable[] source, Comparable[] heap){
         //把source中的元素拷贝到head中，head中的元素就形成了一个无序的堆
        System.arraycopy(source,0,heap,1,source.length);

        //对堆中的元素做下沉调整（从长度的一半处开始，往索引1处扫描）
        for (int i = (heap.length/2); i &gt; 0 ; i--) {
            sink(heap,i, heap.length-1);
        }
    }

    //判断heap堆中索引i处的元素是否小于索引j处的元素
    private static boolean less(Comparable[] heap, int i, int j){
        return heap[i].compareTo(heap[j]) &lt; 0;
    }

    //交换heap堆中i索引和j索引处的值
    private static void exch(Comparable[] heap, int i, int j){
        Comparable temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    //在heap堆中，对target处的元素做下沉，范围是0~range。
    private static void sink(Comparable[] heap, int target, int range){
        while (2*target &lt;=range){
            //找出当前结点的较大结点
            int max;
            if (2*target+1 &lt;=range){
                if (less(heap,2*target,2*target+1)){
                    max = 2*target+1;
                }else {
                    max = 2*target;
                }
            }else {
                max = 2*target;
            }

            //比较当前结点的值和较大子结点的值
            if (!less(heap,target,max)){
                break;
            }
            exch(heap,target,max);

            target = max;

        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HeapSortTest {
    public static void main(String[] args) {
        String[] arr = {"S","O","R","T","E","X","A","M","P","L","E"};

        HeapSort.sort(arr);

        System.out.println(Arrays.toString(arr));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20221005003859000.png" alt="image-20221005003859000"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">BlogLee</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://rookiesnewbie.github.io/2023/03/03/shu-ju-jie-gou-yu-suan-fa/">https://rookiesnewbie.github.io/2023/03/03/shu-ju-jie-gou-yu-suan-fa/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">BlogLee</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">Java数据结构与算法</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/03/03/docker2022/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="Docker升级版">
                        
                        <span class="card-title">Docker升级版</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-03-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            BlogLee
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/docker/">
                        <span class="chip bg-color">docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2023/03/03/shu-ju-jie-gou-yu-suan-fa/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="Java数据结构与算法">
                        
                        <span class="card-title">Java数据结构与算法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            BlogLee
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">Java数据结构与算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <a href="/about" target="_blank">BlogLee</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">215k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "3";
                        var startDate = "3";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/rookiesnewbie" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2049448867@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2049448867" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2049448867" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
