<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="HashMap, BlogLee">
    <meta name="description" content="HashMapHashMap集合的简介
HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>HashMap | BlogLee</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="BlogLee" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">BlogLee</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Concat</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">BlogLee</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Concat
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/2.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">HashMap</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/HashMap/">
                                <span class="chip bg-color">HashMap</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-03
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    33 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap集合的简介"><a href="#HashMap集合的简介" class="headerlink" title="HashMap集合的简介"></a>HashMap集合的简介</h2><p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220921222200760.png" alt="image-20220921222200760"></p>
<p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。<br>JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突(两个对象调用的hashCode方法计算的哈希码值—致导致计算的数组索引值相同)而存在的(“拉链法”解决冲<br>突) </p>
<p>JDK1.8以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为8)并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p>
<p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p>
<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考<code>treeifBin</code>方法</p>
<p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。</p>
<p>特点:</p>
<p>1.存取无序的</p>
<p>⒉.键和值位置都可以是null，但是键位置只能是一个null</p>
<p>3.键位置是唯一的，底层的数据结构控制键的</p>
<p>4.jdk1.8前数据结构是：链表＋数组 jdk1.8之后是:链表＋数组＋红黑树</p>
<p>5.阈值(边界值)&gt;8并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p>
<p>例如</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 {
    public static void main(String[] args) {

        //创建hashmap集合对象
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put("刘德华",53);
        map.put("柳岩",53);
        map.put("张学友",53);
        map.put("郭富城",53);
        map.put("黎明",45);
        map.put("刘德华",45);
        System.out.println(map);
        System.out.println(map.size());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220921222805365.png" alt="image-20220921222805365"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当创建HashMap集合对象的时候，在jdk8前，构造方法中创建一个长度是<strong>16</strong>的<strong>Entry[] table</strong>用来存储键值对数据的。在jdk8以后不是在HashMap的构造方法底层创建数组了，是在第一次调用put方法时创建的数组,<br><strong>Node[] table</strong>用来存储键值对数据的.</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题:"></a>面试题:</h3><h4 id="哈希表底层采用何种算法计算hash值-还有哪些算法可以计算出hash值"><a href="#哈希表底层采用何种算法计算hash值-还有哪些算法可以计算出hash值" class="headerlink" title="哈希表底层采用何种算法计算hash值?还有哪些算法可以计算出hash值?"></a>哈希表底层采用何种算法计算hash值?还有哪些算法可以计算出hash值?</h4><p>底层采用的key的hashCode方法的值结合数组长度进行<strong>无符号右移</strong>(&gt;&gt;&gt;)、<strong>按位异或</strong>(^)、<strong>按位与</strong>(&amp;)计算出索引。</p>
<p>还可以采用：平方取中法，取余数，伪随机数法<br>10%8 = 2 ；11%8 = 3 其他计算方式相率比较低，而位运算效率要高。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220921224315733.png" alt="image-20220921224315733"></p>
<p>假设向哈希表中存储数据<strong>刘德华-40</strong>，假设刘德华计算出的hashCode方法结合数组长度计算出的索引值也是3，那么此时数组空间不是null，此时底层会比较柳岩和刘德华的hash值是否一致，如果不一致，则在此空间上划出一个节点来存储键值对数据刘德华-40这种方式称<strong>为拉链法</strong></p>
<p>假设向哈希表中存储数据柳岩-20，那么首先根据柳岩调用hashCode方法结合数组长度计算出索引肯定3。此时比较后存储数据柳岩和已经存在的数据的hash值是否相等，如果hash值相等，此时发生哈希碰撞。那么底层会调用柳岩所属类String中的equals方法比较两个内容是否相等;</p>
<ul>
<li>相等：则将后添加的数据的value覆盖之前的value</li>
<li>不相等：那么继续向下和其他的数据的key进行比较，如果都不相等，则划出一个节点存储数据</li>
<li>如果节点长度即链表长度大于阈值8并且数组长度大于64则进行将链表变为<strong>红黑树</strong></li>
</ul>
<h4 id="当两个对象的hashCode相等时会怎么样"><a href="#当两个对象的hashCode相等时会怎么样" class="headerlink" title="当两个对象的hashCode相等时会怎么样?"></a>当两个对象的hashCode相等时会怎么样?</h4><p>答：会产生哈希碰撞，若key值内容相同则替换旧的value，不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</p>
<h4 id="何时发生哈希碰撞和什么是哈希碰撞-如何解决哈希碰撞"><a href="#何时发生哈希碰撞和什么是哈希碰撞-如何解决哈希碰撞" class="headerlink" title="何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞?"></a>何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞?</h4><p>答：只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</p>
<h4 id="如果两个键的hashcode相同，如何存储键值对"><a href="#如果两个键的hashcode相同，如何存储键值对" class="headerlink" title="如果两个键的hashcode相同，如何存储键值对?"></a>如果两个键的hashcode相同，如何存储键值对?</h4><p>答：hashcode相同：通过equals比较内容是否相同。相同：则新的value覆盖之前的value<br>                hashcode不相同：则将新的键值对添加到哈希表中</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式:扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p>通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用==<strong>数组+链表+红黑树</strong>==实现，当<strong>链表长度(阀值)超过8</strong>时且当前<strong>数组的长度&gt;64时</strong>，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树(JDK1.8增加了红黑树部分）实现的。如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220921230115628.png" alt="image-20220921230115628"></p>
<p>但是这样的话问题来了，传统hashMap的缺点，jdk1.8为什么引入红黑树?这样结构的话不是更麻烦了吗，为何阀值大于8换成红黑树?</p>
<p>JDK 1.8以前HashMap的实现是<strong>数组+链表</strong>，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候HashMap就相当于一个单链表，假如单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。针对这种情况，JDK 1.8中引入了红黑树（查找时间复杂度为O(logn)）来优化这个问题。当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p>
<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。下面我们在分析源码的时候会介绍。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>上述我们大概阐述了HashMap底层存储数据的方式。为了方便大家更好的理解，我们结合一个存储流程图来进一步说明一下：jdk8存储过程)</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220921232035177.png" alt="image-20220921232035177"></p>
<p>说明:</p>
<p>1、size表示 HashMap中K-V的实时数量，==注意这个不等于数组的长度==。</p>
<p>2、threshold(临界值)=capacity(容量)* loadFactor(加载因子)。这个值是当前已占用数组长度的最大值。size超过这个临界值就重新resize(扩容)，扩容后的HashMap容量是之前容量的<strong>两倍</strong>。</p>
<h2 id="HashMap继承关系"><a href="#HashMap继承关系" class="headerlink" title="HashMap继承关系"></a>HashMap继承关系</h2><p>HashMap的继承关系如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220921232243976.png" alt="image-20220921232243976"></p>
<p>说明：</p>
<ul>
<li>Cloneable空接口，表示可以克隆。创建并返回HashMap对象的一个副本。</li>
<li>Serializable序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li>
<li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li>
</ul>
<p>补充：通过上述继承关系我们发现一个很奇怪的现象，就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。</p>
<pre class="line-numbers language-none"><code class="language-none">据java集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>





<h2 id="HashMap集合类的成员"><a href="#HashMap集合类的成员" class="headerlink" title="HashMap集合类的成员"></a>HashMap集合类的成员</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><h4 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final long serialVersionUID = 362498820763181265L;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="集合的初始化容量-必须是二的n次幂"><a href="#集合的初始化容量-必须是二的n次幂" class="headerlink" title="集合的初始化容量(必须是二的n次幂)"></a>集合的初始化容量(必须是二的n次幂)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//黑认的初始容量是16 -- 1&lt;&lt;4 相当于1*2的4次方---1*16
static final int DEFAULT_INITIAL_CAPACITY = 16;或
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>问题：</strong>为什么必须是2的n次幂? 如果输入值不是2的幂比如10会怎么样? HashMap构造方法还可以指定集合的初始化容量大小:</p>
<p>​           HashMap构造方法还可以指定集合的初始化容量大小:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">HashMap(int initialCapacty) ;//构造一个带指定初始容量和默认加载因子(0.75)的空HashMap。
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。HashMap为了存取高效，要尽星较少碰撞，就是要尽星把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p>
<p>这个算法实际就是取模， <code>hash % length</code>，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化，使用<code>hash &amp;(length-1)</code>，而实际上<code>hash % length</code>等于<code>hash &amp; (length-1)</code>的==<strong>前提是length是2的n次幂。</strong>==</p>
<p>为什么这样能均匀分布减少碰撞呢? 2的n次方实际就是1后面n个0，2的n次方-1实际就是n个1;</p>
<p><strong>举例:</strong></p>
<p>说明：==<strong>按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong>==</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">例如长度为8时候，3&amp;(8-1)=3；  2&amp;(8-1)=2，不同位置上，不碰撞;
例如长度length为8时候，8是2的3次幂。二进制是:1000
length-1 二进制运算:
     1000
-       1 
------------
      111  


hash &amp; (length-1)  这种算法是如何减少hash碰撞的? 可以让数组空间均匀分配
hash：3； 数组长度：8
3 &amp; (8-1)
hash        00000011  3
length-1    00000111  7
----------------------------
			00000011  3  数组索引为3


hash：2； 数组长度：8
2 &amp; (8-1)
hash        00000010  3
length-1    00000111  7
----------------------------
			00000010  2   数组索引为2


如果数组长度不是2的n次幂的情况，计算出的索引特别容易相同，及其容易发生hash碰撞，导致其余数组空间很大程度上并没有存储数据，链表或者红黑树过长，效率降低

hash：3； 数组长度：9
3 &amp; (9-1)
hash        00000011  3
length-1	00001000  8
----------------------------
			00000000  0  数组索引为0

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>小结:</p>
<p>1、由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突</p>
<p>2、另一方面，一般我们可能会想通过%求余来确定位置，这样也可以，只不过性能不如&amp;运算。而且当n是2的幂次方时: hash &amp; (length - 1) == hash % length</p>
<p>3、因此，HashMap容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p>
<p>4、如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static final int tableSizeFor(int cap ) {
        int n  = cap  - 1;
        n  |= n  &gt;&gt;&gt; 1;
        n  |= n  &gt;&gt;&gt; 2;
        n  |= n  &gt;&gt;&gt; 4;
        n  |= n  &gt;&gt;&gt; 8;
        n  |= n  &gt;&gt;&gt; 16;
        return var1 &lt; 0 ? 1 : (n  &gt;= 1073741824 ? 1073741824 : n  + 1);
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>说明:</p>
<p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity(假设是10)，由于HashMap的capacity必须都是2的幂，因此这个方法用于找到大于等于initialCapacity(假设是10)的最小的2的幂(initialCapacity如果就是2的幂，则返回的还是这个数)。</p>
<p>下面分析这个算法:</p>
<p>1)、首先，为什么要对cap做减1操作。<code>int n = cap - 1</code>;<br>这是为了防止，cap已经是2的幂。如果cap已经是2的幂，又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。下面看看这几个无符号右移操作:</p>
<p>2)、如果n这时为0了(经过了cap-1之后)，则经过后面的几次无符号右移依然是0，最后返回的capacity是1(最后有个n+1的操作)。<br>这里只讨论n不等于0的情况。</p>
<p>3)、注意：<strong>l(按位或运算)︰运算规则: 相同的二进制数位上，都是0的时候，结果为0，否则为1。</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
cap = 10
int n = cap - 1; ==&gt; 9

第一次右移（|）
 n  |= n  &gt;&gt;&gt; 1;
 00000000  00000000  00000000  00001001   9
 00000000  00000000  00000000  00001000   9 &gt;&gt;&gt; 1  右移 1位
 ---------------------------------------------------
 00000000  00000000  00000000  00001101   13  n


第二次右移（|）
n = 13
n |= n &gt;&gt;&gt; 2;
 00000000  00000000  00000000  00001101   13
 00000000  00000000  00000000  00000011   13 &gt;&gt;&gt; 2  右移 2位
 ---------------------------------------------------
 00000000  00000000  00000000  00001111   15  n
 
 
 第三次右移（|）
n = 15
n |= n &gt;&gt;&gt; 4;
 00000000  00000000  00000000  00001111   15
 00000000  00000000  00000000  00000000   15 &gt;&gt;&gt; 4  右移 4位
 ---------------------------------------------------
 00000000  00000000  00000000  00001111   15  n
 
 第四次右移（|）
n = 15
n |= n &gt;&gt;&gt; 8;
 00000000  00000000  00000000  00001111   15
 00000000  00000000  00000000  00000000   15 &gt;&gt;&gt; 8  右移 8位
 ---------------------------------------------------
 00000000  00000000  00000000  00001111   15  n
 
 第五次右移（|）
n = 15
n |= n &gt;&gt;&gt; 16;
 00000000  00000000  00000000  00001111   15
 00000000  00000000  00000000  00000000   15 &gt;&gt;&gt; 16  右移 16位
 ---------------------------------------------------
 00000000  00000000  00000000  00001111   15  n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="默认的负载因子，默认值是0-75"><a href="#默认的负载因子，默认值是0-75" class="headerlink" title="默认的负载因子，默认值是0.75"></a>默认的负载因子，默认值是0.75</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">static final float DEFAULT_LOAD_FACTOR = 0.75F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h4 id="集合的最大容量"><a href="#集合的最大容量" class="headerlink" title="集合的最大容量"></a>集合的最大容量</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//集合最大容量的上线为2的30次幂
static final int MAXIMUM_CAPACITY = 1073741824;即
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="当链表的值超过8则会转红黑树-1-8新增"><a href="#当链表的值超过8则会转红黑树-1-8新增" class="headerlink" title="当链表的值超过8则会转红黑树(1.8新增)"></a>当链表的值超过8则会转红黑树(1.8新增)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//当桶（bucket）上的结点数大于这个值时会转为红黑树
static final int TREEIFY_THRESHOLD = 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>问题：</strong>为什么Map桶中节点个数超过8才转为红黑树?</p>
<p>答：8这个阈值定义在HashMap中，针对这个成员变星，在源码的注释中只说明了8是bin (bin就是bucket(桶))从链表转成树的阈值，但是并没有说明为什么是8</p>
<h4 id="当链表的值小于6则会从红黑树转回链表"><a href="#当链表的值小于6则会从红黑树转回链表" class="headerlink" title="当链表的值小于6则会从红黑树转回链表"></a>当链表的值小于6则会从红黑树转回链表</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">static final int UNTREEIFY_THRESHOLD = 6;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h4 id="当Map里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于-x3D-x3D-4-TREEIFY-THRESHOLD-8-x3D-x3D"><a href="#当Map里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于-x3D-x3D-4-TREEIFY-THRESHOLD-8-x3D-x3D" class="headerlink" title="当Map里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于==4* TREEIFY_THRESHOLD(8)=="></a>当Map里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于==4* TREEIFY_THRESHOLD(8)==</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//桶中结构转化为红黑树对应的数组长度最小的值
static final int MIN_TREEIFY_CAPACITY = 64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="table用来初始化-必须是二的n次幂-重点"><a href="#table用来初始化-必须是二的n次幂-重点" class="headerlink" title="table用来初始化(必须是二的n次幂)(重点)"></a>table用来初始化(必须是二的n次幂)(重点)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//存储元素的数组
transient HashMap.Node&lt;K, V&gt;[] table;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">static class Node&lt;K, V&gt; implements Entry&lt;K, V&gt; {
    final int hash;
    final K key;
    V value;
    HashMap.Node&lt;K, V&gt; next;

    Node(int var1, K var2, V var3, HashMap.Node&lt;K, V&gt; var4) {
        this.hash = var1;
        this.key = var2;
        this.value = var3;
        this.next = var4;
    }

    public final K getKey() {
        return this.key;
    }

    public final V getValue() {
        return this.value;
    }

    public final String toString() {
        return this.key + "=" + this.value;
    }

    public final int hashCode() {
        return Objects.hashCode(this.key) ^ Objects.hashCode(this.value);
    }

    public final V setValue(V var1) {
        Object var2 = this.value;
        this.value = var1;
        return var2;
    }

    public final boolean equals(Object var1) {
        if (var1 == this) {
            return true;
        } else {
            if (var1 instanceof Entry) {
                Entry var2 = (Entry)var1;
                if (Objects.equals(this.key, var2.getKey()) &amp;&amp; Objects.equals(this.value, var2.getValue())) {
                    return true;
                }
            }

            return false;
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>table在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组,jdk8之前数组类型是Entry&lt;K.V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口:Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p>
<h4 id="用来存放缓存"><a href="#用来存放缓存" class="headerlink" title="用来存放缓存"></a>用来存放缓存</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//存放具体的集合
transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="HashMap中存放元素的个数（重点）"><a href="#HashMap中存放元素的个数（重点）" class="headerlink" title="HashMap中存放元素的个数（重点）"></a>HashMap中存放元素的个数（重点）</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//存放元素的个数，注意这个不等于数组的长度
transient int size;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>size为HashMap中K-V的实时数量，不是数组的table长度</p>
<h4 id="用来记录HashMap的修改次数"><a href="#用来记录HashMap的修改次数" class="headerlink" title="用来记录HashMap的修改次数"></a>用来记录HashMap的修改次数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//每次扩容和更改map结构的计数器
transient int modCount;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="用来调整大小下—个容量的值计算方式为-容量-负载因子"><a href="#用来调整大小下—个容量的值计算方式为-容量-负载因子" class="headerlink" title="用来调整大小下—个容量的值计算方式为(容量*负载因子)"></a>用来调整大小下—个容量的值计算方式为(容量*负载因子)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//临界值（阈值）当实际大小(容量（数组长度）*负载因子（0.75）)超过临界值时，会进行扩容（16*0.75）=12
int threshold;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="哈希表的加载因子-重点"><a href="#哈希表的加载因子-重点" class="headerlink" title="哈希表的加载因子(重点)"></a>哈希表的加载因子(重点)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//加载因子，默认值0.75
final float loadFactor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>说明：</strong></p>
<p>1、<strong>loadFctor</strong>加载因子，是用来衡量HashMap满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为: <code>size / capacity</code>，而不是占用桶的数量去除以capacity。capacity是桶的数量，也就是table的长度length。</p>
<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。</strong></p>
<p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p>
<p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p>
<p><strong>构造方法：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public HashMap(int initialCapacity,
               float loadFactor)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>构造一个空 <code>HashMap</code>具有指定的初始容量和加载因子。 </p>
<p><strong>参数 ：</strong></p>
<p><code>initialCapacity</code> -初始容量 （默认16）</p>
<p><code>loadFactor</code> -负荷系数 （默认0.75）</p>
<p><strong>异常 ：</strong></p>
<p><code>IllegalArgumentException</code>如果初始容量为负或负载因子是负的 </p>
<p><strong>为什么加载因子设置为0.75，初始化临界值是12?</strong></p>
<p>答：loadFactor越趋近于1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><img src="https://raw.githubusercontent.com/rookiesnewbie/images/master/images/image-20220922121155828.png" alt="image-20220922121155828"></p>
<p><strong>例如：</strong></p>
<p>若加载因子是0.4。那么16*0.4 = 6，如果数组中满6个空间就扩容会造成数组利用率太低了。</p>
<p>加载因子是0.9。那么16*0.9 = 14那么这样就会导致链表有点多了。导致查找元素效率低。</p>
<p><strong>因此经过大量测试，官方给出加载因子时0.75是最佳方案。</strong></p>
<p><strong>threshold计算公式:</strong> capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。当<strong>Size &gt;= threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个意思就是衡量数组是否需要扩增的一个标准。扩容后的HashMap容量是之前容量的两倍。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap中重要的构造方法，分别如下：</p>
<h4 id="构造—个空的-HashMap，默认初始容量-16-和默认负载因子-0-75-。"><a href="#构造—个空的-HashMap，默认初始容量-16-和默认负载因子-0-75-。" class="headerlink" title="构造—个空的 HashMap，默认初始容量(16)和默认负载因子(0.75)。"></a>构造—个空的 HashMap，默认初始容量(16)和默认负载因子(0.75)。</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public HashMap() {
       this.loadFactor = DEFAULT_LOAD_FACTOR;//将黑认的加载因子0.75赋值给1oadFactor，并没有创建数组

   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="构造一个具有指定的初始容量和默认负载因子-0-75-HashMap。"><a href="#构造一个具有指定的初始容量和默认负载因子-0-75-HashMap。" class="headerlink" title="构造一个具有指定的初始容量和默认负载因子(0.75) HashMap。"></a>构造一个具有指定的初始容量和默认负载因子(0.75) HashMap。</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//指定“容量大小”的构造函数

public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="构造一个具有指定的初始容量和负载因子的HashMap。我们来分析一下。"><a href="#构造一个具有指定的初始容量和负载因子的HashMap。我们来分析一下。" class="headerlink" title="构造一个具有指定的初始容量和负载因子的HashMap。我们来分析一下。"></a>构造一个具有指定的初始容量和负载因子的HashMap。我们来分析一下。</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*
    指定“容量大小”和“加载因子”的构造函数		  initialcapacity:指定的容量
    loadFactor:指定的加载因子
*/

public HashMap(int initialCapacity, float loadFactor) {
    //判断初始化容量initialcapacity是否小于0
        if (initialCapacity &lt; 0) {
            //如果小于0，则抛出非法的参数异常IllegalArgumentException 

            throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
        } else {
            //判断初始化容量initialcapacity是否大于集合的最大容量MAXIMUM_CAPACITY-》2的30次幂
            if (initialCapacity &gt; 1073741824) {
                initialCapacity = 1073741824;
            }

            if (!(loadFactor &lt;= 0.0F) &amp;&amp; !Float.isNaN(loadFactor)) {
                this.loadFactor = loadFactor;
                this.threshold = tableSizeFor(initialCapacity);
            } else {
                throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
            }
        }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="包含另一个”Map”的构造函数"><a href="#包含另一个”Map”的构造函数" class="headerlink" title="包含另一个”Map”的构造函数"></a>包含另一个”Map”的构造函数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//构造一个映射关系与指定Map相同的新 HashMap
public HashMap(Map&lt;? extends K, ? extends V&gt; var1) {
    //负载因子1oadFactor变为黑默认的负载因子0.75
        this.loadFactor = 0.75F;
        this.putMapEntries(var1, false);
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后调用了putMapEntries，来看一下方法实现:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; var1, boolean var2) {
        //获取参数集合的长度
        int var3 = var1.size();
        if (var3 &gt; 0) {
            if (this.table == null) { //判断table是否已经初始化
                
                //未初始化，var3为var1的实际元素个数
                float var4 = (float)var3 / this.loadFactor + 1.0F;
                int var5 = var4 &lt; 1.07374182E9F ? (int)var4 : 1073741824;
                if (var5 &gt; this.threshold) {
                    this.threshold = tableSizeFor(var5);
                }
            } else if (var3 &gt; this.threshold) {
                this.resize();
            }

            Iterator var8 = var1.entrySet().iterator();

            while(var8.hasNext()) {
                Entry var9 = (Entry)var8.next();
                Object var6 = var9.getKey();
                Object var7 = var9.getValue();
                this.putVal(hash(var6), var6, var7, false, var2);
            }
        }

    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
    //获取参数集合的长度    
    int s = m.size();
        if (s &gt; 0) {
            if (table == null) { // 判断table是否已经初始化
                
                //未初始化，var3为var1的实际元素个数
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &gt; threshold)
                resize();
            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





























































<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h2 id="扩容方法-resize"><a href="#扩容方法-resize" class="headerlink" title="扩容方法_resize"></a>扩容方法_resize</h2><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>想要了解HashMap的扩容机制你要有这两个问题?</p>
<ul>
<li><p>什么时候才需要扩容？</p>
</li>
<li><p>HashMap的扩容是什么？</p>
</li>
</ul>
<p><strong>1、什么时候才需要扩容？</strong></p>
<p>答：当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们<br>已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</p>
<p><strong>补充:</strong></p>
<p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p>
<p><strong>2、HashMap的扩容是什么？</strong></p>
<p>答：进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的(n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到**”原位置+旧容量”**这个位置。</p>
<p>怎么理解呢?</p>
<p>例如我们从16扩展为32时，具体的变化如下所示:</p>
<pre class="line-numbers language-none"><code class="language-none">假设原数组长度：16   n = 16   n-1 = 15
hash1、hash2都是假设出来的
(n-1) &amp; hash
				 	0000 0000 0000 0000 0000 0000 0001 0000    16
				 	0000 0000 0000 0000 0000 0000 0000 1111    15（n-1）
hash1(key1):     	1111 1111 1111 1111 0000 1111 0000 0101
hash2(key2):     	1111 1111 1111 1111 0000 1111 0001 0101
-------------------------------------------------------------------------
(n-1) &amp;hash1(key1): 0000 0000 0000 0000 0000 0000 0000 0101    索引为5
(n-1) &amp;hash2(key2): 0000 0000 0000 0000 0000 0000 0000 0101    索引为5


数组长度扩容：16 -----》 32 ，则 n-1 = 31 
(n-1) &amp; hash
				 	0000 0000 0000 0000 0000 0000 0010 0000    32
				 	0000 0000 0000 0000 0000 0000 0001 1111    31（n-1）
hash1(key1):     	1111 1111 1111 1111 0000 1111 0000 0101
hash2(key2):     	1111 1111 1111 1111 0000 1111 0001 0101
-------------------------------------------------------------------------
(n-1) &amp;hash1(key1): 0000 0000 0000 0000 0000 0000 0000 0101    索引为5
(n-1) &amp;hash2(key2): 0000 0000 0000 0000 0000 0000 0001 0101    索引为21（5+16）

因此，扩容之后的索引位置要么是原来索引，要么是原来索引＋旧数组的容量
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="resize源代码"><a href="#resize源代码" class="headerlink" title="resize源代码"></a>resize源代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="HashMap的遍历"><a href="#HashMap的遍历" class="headerlink" title="HashMap的遍历"></a>HashMap的遍历</h2><h3 id="分别遍历key和value"><a href="#分别遍历key和value" class="headerlink" title="分别遍历key和value"></a>分别遍历key和value</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 {
    public static void main(String[] args) {

        //创建hashmap集合对象
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
        map.put("刘德华",53);
        map.put("柳岩",53);
        map.put("张学友",53);
        map.put("郭富城",53);
        map.put("黎明",45);
        map.put("刘德华",45);
        map.put(null,45);
        map.put(null,45);
      
        //调用method方法
        method_1(map);

    }

    //分别遍历key和value
    private static  void method_1(HashMap&lt;String,Object&gt; map){
        //获取所有的key
        Set&lt;String&gt; keys = map.keySet();
        for (String key : keys) {
            System.out.println(key);
        }

        //获取所有的value
        Collection&lt;Object&gt; values = map.values();
        for (Object value : values) {
            System.out.println(value);
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="使用iterator遍历"><a href="#使用iterator遍历" class="headerlink" title="使用iterator遍历"></a>使用iterator遍历</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 {
    public static void main(String[] args) {

        //创建hashmap集合对象
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
        map.put("刘德华",53);
        map.put("柳岩",53);
        map.put("张学友",53);
        map.put("郭富城",53);
        map.put("黎明",45);
        map.put("刘德华",45);
        map.put(null,45);
        map.put(null,45);

        //调用method方法
        method_2(map);
    }

       //使用iterator遍历
    private static  void method_2(HashMap&lt;String,Object&gt; map) {
        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();
        for (Iterator&lt;Map.Entry&lt;String,Object&gt;&gt; it = entries.iterator();it.hasNext();) {
            Map.Entry&lt;String, Object&gt; entry = it.next();
            System.out.println(entry.getKey() +"----&gt;" +entry.getValue());
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="通过get方式-不建议使用，原因是：该方法效率低"><a href="#通过get方式-不建议使用，原因是：该方法效率低" class="headerlink" title="通过get方式,不建议使用，原因是：该方法效率低"></a>通过get方式,不建议使用，原因是：该方法效率低</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 {
    public static void main(String[] args) {

        //创建hashmap集合对象
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
        map.put("刘德华",53);
        map.put("柳岩",53);
        map.put("张学友",53);
        map.put("郭富城",53);
        map.put("黎明",45);
        map.put("刘德华",45);
        map.put(null,45);
        map.put(null,45);
       
        //调用method方法
        method_3(map);


    }

    //通过get方式,不建议使用，原因是：该方法效率低
    private static  void method_3(HashMap&lt;String,Object&gt; map){
        Set&lt;String&gt; keys = map.keySet();
        for (String key : keys) {
            Object value = map.get(key);
            System.out.println(key + "----&gt;" + value);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="使用Map接口中的默认方法"><a href="#使用Map接口中的默认方法" class="headerlink" title="使用Map接口中的默认方法"></a>使用Map接口中的默认方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 {
    public static void main(String[] args) {

        //创建hashmap集合对象
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(10);
        map.put("刘德华",53);
        map.put("柳岩",53);
        map.put("张学友",53);
        map.put("郭富城",53);
        map.put("黎明",45);
        map.put("刘德华",45);
        map.put(null,45);
        map.put(null,45);
       
        //调用method方法
        method_4(map);

    }
    //jdk8以后使用Map接口中的默认方法：
   /*
    default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)
    对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。
    参数:
        BiConsumer消费接口:
        抽象方法:void accept(T t,U u)对给定的参数执行此操作。
        参数:
            t key
            u value
   */

    private static  void method_4(HashMap&lt;String,Object&gt; map){
        map.forEach((key,value) -&gt;{
            System.out.println(key + "----&gt;"+ value);
        });
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="如何设计多个非重复的键值对要存储HashMap的初始化"><a href="#如何设计多个非重复的键值对要存储HashMap的初始化" class="headerlink" title="如何设计多个非重复的键值对要存储HashMap的初始化?"></a>如何设计多个非重复的键值对要存储HashMap的初始化?</h2><h3 id="HashMap的初始化问题描述"><a href="#HashMap的初始化问题描述" class="headerlink" title="HashMap的初始化问题描述"></a>HashMap的初始化问题描述</h3><p>如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化HashMap的时候就应该指定它的容量，以防止HashMap自动扩容，影响使用效率。</p>
<p>默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16)。</p>
<p>《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。</p>
<p><strong>【推荐】集合初始化时，指定集合初始值大小。</strong></p>
<p><strong>说明: HashMap使用HashMap(int initialcapacity)初始化。</strong></p>
<p>那么，为什么要这么建议?</p>
<p>当然，以上建议也是有理论支撑的。我们上面介绍过，HashMap的扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数(size）超过临界值(threshold）时就会自动扩容。在HashMap中,threshold = loadFactor * capacity。</p>
<p>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p>
<p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容星设置成多少为好呢?</p>
<h3 id="HashMap中容量的初始化"><a href="#HashMap中容量的初始化" class="headerlink" title="HashMap中容量的初始化"></a>HashMap中容量的初始化</h3><p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢?</p>
<p>关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议:</p>
<p>正例：==<strong>initialCapacity=(需要存储的元素个数 / 负载因子) + 1，注意负载因子(即loaderfactor）默认为0.75,</strong>==</p>
<p>也就是说，如果我们设置的默认值是7，经过jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到8*0.75= 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽星减少扩容。原因也已经分析过。如果我们通过<code>initialCapacity / 0.75F + 1.0F</code>计算，<code>7 / 0.75 + 1 = 10</code>,10经过jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p>
<p>当HashMap内部维护的哈希表的容量达到75%时(默认情况下)，会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容星要设置成<code>initialCapacity / 0.75 + 1</code>的话，可以有效的减少冲突也可以减小误差。</p>
<p>所以，可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成: <code>initialcCapacity / 0.75F + 1.0F</code>是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p>
<p>我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。</p>
<p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成<code>initialCapacity / 0.75F + 1.0F</code>。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">BlogLee</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://rookiesnewbie.github.io/2023/03/03/hashmap/">https://rookiesnewbie.github.io/2023/03/03/hashmap/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">BlogLee</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/HashMap/">
                                    <span class="chip bg-color">HashMap</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/03/03/docker/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="Docker">
                        
                        <span class="card-title">Docker</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-03-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            BlogLee
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/docker/">
                        <span class="chip bg-color">docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/03/03/vue-zu-jian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="Vue">
                        
                        <span class="card-title">Vue</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            BlogLee
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/vue/">
                        <span class="chip bg-color">vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <a href="/about" target="_blank">BlogLee</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">215k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "3";
                        var startDate = "3";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/rookiesnewbie" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2049448867@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2049448867" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2049448867" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
